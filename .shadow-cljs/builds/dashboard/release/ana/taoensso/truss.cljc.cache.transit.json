["^ ","~:output",["^ ","~:js","goog.provide('taoensso.truss');\n/**\n * Returns true iff `sub-map` is a (possibly nested) submap of `super-map`,\n *   i.e. iff every (nested) value in `sub-map` has the same (nested) value in `super-map`.\n * \n *   `sub-map` may contain special values:\n *  `:submap/nx`     - Matches iff `super-map` does not contain key\n *  `:submap/ex`     - Matches iff `super-map` does     contain key (any     val)\n *  `:submap/some`   - Matches iff `super-map` does     contain key (non-nil val)\n *  (fn [super-val]) - Matches iff given unary predicate returns truthy\n * \n *   Uses stack recursion so supports only limited nesting.\n */\ntaoensso.truss.submap_QMARK_ = (function taoensso$truss$submap_QMARK_(super_map,sub_map){\nreturn cljs.core.reduce_kv((function (_,sub_key,sub_val){\nif(cljs.core.map_QMARK_(sub_val)){\nvar super_val = cljs.core.get.cljs$core$IFn$_invoke$arity$2(super_map,sub_key);\nvar temp__5823__auto__ = (function (){var and__5140__auto__ = cljs.core.map_QMARK_(super_val);\nif(and__5140__auto__){\nreturn (taoensso.truss.submap_QMARK_.cljs$core$IFn$_invoke$arity$2 ? taoensso.truss.submap_QMARK_.cljs$core$IFn$_invoke$arity$2(super_val,sub_val) : taoensso.truss.submap_QMARK_.call(null,super_val,sub_val));\n} else {\nreturn and__5140__auto__;\n}\n})();\nif(cljs.core.truth_(temp__5823__auto__)){\nvar match_QMARK_ = temp__5823__auto__;\nreturn true;\n} else {\nreturn cljs.core.reduced(false);\n}\n} else {\nvar super_val = cljs.core.get.cljs$core$IFn$_invoke$arity$3(super_map,sub_key,new cljs.core.Keyword(\"taoensso.truss\",\"nx\",\"taoensso.truss/nx\",1464090303));\nvar temp__5823__auto__ = (function (){var temp__5823__auto__ = ((cljs.core.fn_QMARK_(sub_val))?sub_val:null);\nif(cljs.core.truth_(temp__5823__auto__)){\nvar pred_fn = temp__5823__auto__;\nreturn (pred_fn.cljs$core$IFn$_invoke$arity$1 ? pred_fn.cljs$core$IFn$_invoke$arity$1(super_val) : pred_fn.call(null,super_val));\n} else {\nvar G__22664 = sub_val;\nvar G__22664__$1 = (((G__22664 instanceof cljs.core.Keyword))?G__22664.fqn:null);\nswitch (G__22664__$1) {\ncase \"submap/nx\":\nreturn cljs.core.keyword_identical_QMARK_(super_val,new cljs.core.Keyword(\"taoensso.truss\",\"nx\",\"taoensso.truss/nx\",1464090303));\n\nbreak;\ncase \"submap/ex\":\nreturn (!(cljs.core.keyword_identical_QMARK_(super_val,new cljs.core.Keyword(\"taoensso.truss\",\"nx\",\"taoensso.truss/nx\",1464090303))));\n\nbreak;\ncase \"submap/some\":\nreturn (!((super_val == null)));\n\nbreak;\ndefault:\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(sub_val,super_val);\n\n}\n}\n})();\nif(cljs.core.truth_(temp__5823__auto__)){\nvar match_QMARK_ = temp__5823__auto__;\nreturn true;\n} else {\nreturn cljs.core.reduced(false);\n}\n}\n}),true,sub_map);\n});\n/**\n * Context map to assoc to `:truss/ctx` key of `truss/ex-info` data map.\n * \n *   Re/bind dynamic        value using `with-ctx`, `with-ctx+`, or `binding`.\n *   Modify  root (default) value using `set-ctx!`.\n * \n *   As with all dynamic Clojure vars, \"binding conveyance\" applies when\n *   using futures, agents, etc.\n */\ntaoensso.truss._STAR_ctx_STAR_ = null;\n/**\n * Private, don't use.\n */\ntaoensso.truss.ex_info_STAR_ = (function taoensso$truss$ex_info_STAR_(ns,coords,msg,data_map,cause){\nvar data_map__$1 = (cljs.core.truth_(coords)?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"ns\",\"ns\",441598760),ns,new cljs.core.Keyword(null,\"coords\",\"coords\",-599429112),coords], null),data_map):cljs.core.conj.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"ns\",\"ns\",441598760),ns], null),data_map));\nvar data_map__$2 = (function (){var temp__5823__auto__ = taoensso.truss._STAR_ctx_STAR_;\nif(cljs.core.truth_(temp__5823__auto__)){\nvar ctx = temp__5823__auto__;\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(data_map__$1,new cljs.core.Keyword(\"truss\",\"ctx\",\"truss/ctx\",-336831129),ctx);\n} else {\nreturn data_map__$1;\n}\n})();\nreturn cljs.core.ex_info.cljs$core$IFn$_invoke$arity$3(msg,data_map__$2,cause);\n});\n/**\n * Private, don't use.\n */\ntaoensso.truss.unexpected_arg_BANG__STAR_ = (function taoensso$truss$unexpected_arg_BANG__STAR_(ns,coords,arg,kvs){\nthrow taoensso.truss.ex_info_STAR_(ns,coords,(function (){var or__5142__auto__ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(kvs,new cljs.core.Keyword(null,\"msg\",\"msg\",-1386103444));\nif(cljs.core.truth_(or__5142__auto__)){\nreturn or__5142__auto__;\n} else {\nreturn (\"\"+\"Unexpected argument: \"+cljs.core.str.cljs$core$IFn$_invoke$arity$1((((arg == null))?\"<nil>\":arg)));\n}\n})(),cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(kvs,new cljs.core.Keyword(null,\"msg\",\"msg\",-1386103444)),new cljs.core.Keyword(null,\"arg\",\"arg\",-1747261837),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"value\",\"value\",305978217),arg,new cljs.core.Keyword(null,\"type\",\"type\",1174270348),cljs.core.type(arg)], null)),null);\n});\n/**\n * Set `*ctx*` var's default (root) value. See `*ctx*` for details.\n */\ntaoensso.truss.set_ctx_BANG_ = (function taoensso$truss$set_ctx_BANG_(root_ctx_val){\nreturn (taoensso.truss._STAR_ctx_STAR_ = root_ctx_val);\n});\n/**\n * Returns `new-ctx` given `old-ctx` and an update map or fn.\n */\ntaoensso.truss.update_ctx = (function taoensso$truss$update_ctx(old_ctx,update_map_or_fn){\nif((update_map_or_fn == null)){\nreturn old_ctx;\n} else {\nif(cljs.core.map_QMARK_(update_map_or_fn)){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(old_ctx,update_map_or_fn);\n} else {\nif(cljs.core.ifn_QMARK_(update_map_or_fn)){\nreturn (update_map_or_fn.cljs$core$IFn$_invoke$arity$1 ? update_map_or_fn.cljs$core$IFn$_invoke$arity$1(old_ctx) : update_map_or_fn.call(null,old_ctx));\n} else {\nreturn taoensso.truss.unexpected_arg_BANG__STAR_(\"taoensso.truss\",new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [194,5], null),update_map_or_fn,new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"param\",\"param\",2013631823),new cljs.core.Symbol(null,\"update-map-or-fn\",\"update-map-or-fn\",1067081399,null),new cljs.core.Keyword(null,\"context\",\"context\",-830191113),new cljs.core.Symbol(\"taoensso.truss\",\"update-ctx\",\"taoensso.truss/update-ctx\",2138642429,null),new cljs.core.Keyword(null,\"expected\",\"expected\",1583670997),new cljs.core.PersistentHashSet(null, new cljs.core.PersistentArrayMap(null, 3, [null,\"null\",new cljs.core.Symbol(null,\"map\",\"map\",-1282745308,null),\"null\",new cljs.core.Symbol(null,\"fn\",\"fn\",465265323,null),\"null\"], null), null)], null));\n\n}\n}\n}\n});\n/**\n * Returns true iff given platform error (`Throwable` or `js/Error`).\n */\ntaoensso.truss.error_QMARK_ = (function taoensso$truss$error_QMARK_(x){\nreturn (x instanceof Error);\n});\n/**\n * Private, don't use.\n *   Returns root cause of given platform error.\n */\ntaoensso.truss.ex_root = (function taoensso$truss$ex_root(x){\nif(cljs.core.truth_(taoensso.truss.error_QMARK_(x))){\nvar error = x;\nwhile(true){\nvar temp__5823__auto__ = cljs.core.ex_cause(error);\nif(cljs.core.truth_(temp__5823__auto__)){\nvar cause = temp__5823__auto__;\nvar G__22977 = cause;\nerror = G__22977;\ncontinue;\n} else {\nreturn error;\n}\nbreak;\n}\n} else {\nreturn null;\n}\n});\n/**\n * Private, don't use.\n *   Returns class symbol of given platform error.\n */\ntaoensso.truss.ex_type = (function taoensso$truss$ex_type(x){\nif((x instanceof cljs.core.ExceptionInfo)){\nreturn new cljs.core.Symbol(\"cljs.core\",\"ExceptionInfo\",\"cljs.core/ExceptionInfo\",701839050,null);\n} else {\nif((x instanceof Error)){\nreturn cljs.core.symbol.cljs$core$IFn$_invoke$arity$2(\"js\",x.name);\n} else {\nreturn null;\n}\n}\n});\n/**\n * Private, don't use.\n *   Returns ?{:keys [type msg data]} for given platform error.\n */\ntaoensso.truss.ex_map_STAR_ = (function taoensso$truss$ex_map_STAR_(x){\nvar temp__5825__auto__ = cljs.core.ex_message(x);\nif(cljs.core.truth_(temp__5825__auto__)){\nvar msg = temp__5825__auto__;\nvar temp__5823__auto__ = cljs.core.not_empty(cljs.core.ex_data(x));\nif(cljs.core.truth_(temp__5823__auto__)){\nvar data = temp__5823__auto__;\nreturn new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"type\",\"type\",1174270348),taoensso.truss.ex_type(x),new cljs.core.Keyword(null,\"msg\",\"msg\",-1386103444),msg,new cljs.core.Keyword(null,\"data\",\"data\",-232669377),data], null);\n} else {\nreturn new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"type\",\"type\",1174270348),taoensso.truss.ex_type(x),new cljs.core.Keyword(null,\"msg\",\"msg\",-1386103444),msg], null);\n}\n} else {\nreturn null;\n}\n});\n/**\n * Private, don't use.\n *   Returns vector cause chain of given platform error.\n */\ntaoensso.truss.ex_chain = (function taoensso$truss$ex_chain(var_args){\nvar G__22757 = arguments.length;\nswitch (G__22757) {\ncase 1:\nreturn taoensso.truss.ex_chain.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn taoensso.truss.ex_chain.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",arguments.length].join(\"\")));\n\n}\n});\n\n(taoensso.truss.ex_chain.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn taoensso.truss.ex_chain.cljs$core$IFn$_invoke$arity$2(false,x);\n}));\n\n(taoensso.truss.ex_chain.cljs$core$IFn$_invoke$arity$2 = (function (as_maps_QMARK_,x){\nif(cljs.core.truth_(taoensso.truss.error_QMARK_(x))){\nvar xf = (cljs.core.truth_(as_maps_QMARK_)?taoensso.truss.ex_map_STAR_:cljs.core.identity);\nvar acc = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [(xf.cljs$core$IFn$_invoke$arity$1 ? xf.cljs$core$IFn$_invoke$arity$1(x) : xf.call(null,x))], null);\nvar error = x;\nwhile(true){\nvar temp__5823__auto__ = cljs.core.ex_cause(error);\nif(cljs.core.truth_(temp__5823__auto__)){\nvar cause = temp__5823__auto__;\nvar G__22990 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(acc,(xf.cljs$core$IFn$_invoke$arity$1 ? xf.cljs$core$IFn$_invoke$arity$1(cause) : xf.call(null,cause)));\nvar G__22991 = cause;\nacc = G__22990;\nerror = G__22991;\ncontinue;\n} else {\nreturn acc;\n}\nbreak;\n}\n} else {\nreturn null;\n}\n}));\n\n(taoensso.truss.ex_chain.cljs$lang$maxFixedArity = 2);\n\n/**\n * Private, don't use.\n *   Returns ?{:keys [type msg data chain trace]} for given platform error.\n */\ntaoensso.truss.ex_map = (function taoensso$truss$ex_map(x){\nvar temp__5825__auto__ = taoensso.truss.ex_chain.cljs$core$IFn$_invoke$arity$1(x);\nif(cljs.core.truth_(temp__5825__auto__)){\nvar chain = temp__5825__auto__;\nvar maps = cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(taoensso.truss.ex_map_STAR_,chain);\nvar root = cljs.core.peek(chain);\nvar root_map = cljs.core.peek(maps);\nreturn taoensso.truss.impl.assoc_some.cljs$core$IFn$_invoke$arity$2(root_map,new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"chain\",\"chain\",15631029),maps,new cljs.core.Keyword(null,\"trace\",\"trace\",-1082747415),(function (){var temp__5825__auto____$1 = root.stack;\nif(cljs.core.truth_(temp__5825__auto____$1)){\nvar st = temp__5825__auto____$1;\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(st,\"\")){\nreturn null;\n} else {\nreturn st;\n}\n} else {\nreturn null;\n}\n})()], null));\n} else {\nreturn null;\n}\n});\n/**\n * Given a platform error and criteria for matching, returns the error if it\n *   matches all criteria. Otherwise returns nil.\n * \n *   `kind` may be:\n *  - A class (`ArithmeticException`, `AssertionError`, etc.)\n *  - A special keyword as given to `try*` (`:default`, `:common`, `:ex-info`, `:all`)\n *  - A set of `kind`s  as above, at least one of which must match\n *  - A predicate function, (fn match? [x]) -> bool\n * \n *   `pattern` may be:\n *  - A string or Regex against which `ex-message` must match\n *  - A map             against which `ex-data`    must match using `submap?`\n *  - A set of `pattern`s as above, at least one of which must match\n * \n *   When an error with (nested) causes doesn't match, a match will be attempted\n *   against its (nested) causes.\n * \n *   This is a low-level util, see also `throws`, `throws?`.\n */\ntaoensso.truss.matching_error = (function taoensso$truss$matching_error(var_args){\nvar G__22805 = arguments.length;\nswitch (G__22805) {\ncase 1:\nreturn taoensso.truss.matching_error.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn taoensso.truss.matching_error.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn taoensso.truss.matching_error.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",arguments.length].join(\"\")));\n\n}\n});\n\n(taoensso.truss.matching_error.cljs$core$IFn$_invoke$arity$1 = (function (error){\nreturn error;\n}));\n\n(taoensso.truss.matching_error.cljs$core$IFn$_invoke$arity$2 = (function (kind,error){\nvar temp__5825__auto__ = (((kind instanceof cljs.core.Keyword))?(function (){var G__22809 = kind;\nvar G__22809__$1 = (((G__22809 instanceof cljs.core.Keyword))?G__22809.fqn:null);\nswitch (G__22809__$1) {\ncase \"default\":\ncase \"all-but-critical\":\nreturn (!((error == null)));\n\nbreak;\ncase \"common\":\nreturn (error instanceof Error);\n\nbreak;\ncase \"ex-info\":\nreturn (error instanceof cljs.core.ExceptionInfo);\n\nbreak;\ncase \"all\":\ncase \"any\":\nreturn (!((error == null)));\n\nbreak;\ndefault:\nthrow taoensso.truss.ex_info_STAR_(\"taoensso.truss\",new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [405,21], null),\"Unexpected Truss `matching-error` `kind` keyword\",new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"given\",\"given\",716253602),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"value\",\"value\",305978217),kind,new cljs.core.Keyword(null,\"type\",\"type\",1174270348),cljs.core.type(kind)], null),new cljs.core.Keyword(null,\"expected\",\"expected\",1583670997),new cljs.core.PersistentHashSet(null, new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\"default\",\"default\",-1987822328),\"null\",new cljs.core.Keyword(null,\"all\",\"all\",892129742),\"null\",new cljs.core.Keyword(null,\"common\",\"common\",-1822281391),\"null\",new cljs.core.Keyword(null,\"ex-info\",\"ex-info\",2114560529),\"null\"], null), null)], null),null);\n\n}\n})():(cljs.core.truth_(taoensso.truss.error_QMARK_(kind))?cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(kind,error):((cljs.core.fn_QMARK_(kind))?(kind.cljs$core$IFn$_invoke$arity$1 ? kind.cljs$core$IFn$_invoke$arity$1(error) : kind.call(null,error)):((cljs.core.set_QMARK_(kind))?taoensso.truss.impl.rsome((function (p1__22788_SHARP_){\nreturn taoensso.truss.matching_error.cljs$core$IFn$_invoke$arity$2(p1__22788_SHARP_,error);\n}),kind):(error instanceof kind)\n))));\nif(cljs.core.truth_(temp__5825__auto__)){\nvar match_QMARK_ = temp__5825__auto__;\nreturn error;\n} else {\nreturn null;\n}\n}));\n\n(taoensso.truss.matching_error.cljs$core$IFn$_invoke$arity$3 = (function (kind,pattern,error){\nvar temp__5823__auto__ = (function (){var and__5140__auto__ = taoensso.truss.matching_error.cljs$core$IFn$_invoke$arity$2(kind,error);\nif(cljs.core.truth_(and__5140__auto__)){\nif((pattern == null)){\nreturn true;\n} else {\nif(cljs.core.set_QMARK_(pattern)){\nreturn taoensso.truss.impl.rsome((function (p1__22791_SHARP_){\nreturn taoensso.truss.matching_error.cljs$core$IFn$_invoke$arity$3(kind,p1__22791_SHARP_,error);\n}),pattern);\n} else {\nif(typeof pattern === 'string'){\nreturn taoensso.truss.impl.str_contains_QMARK_(cljs.core.ex_message(error),pattern);\n} else {\nif(taoensso.truss.impl.re_pattern_QMARK_(pattern)){\nreturn cljs.core.re_find(pattern,cljs.core.ex_message(error));\n} else {\nif(cljs.core.map_QMARK_(pattern)){\nvar temp__5825__auto__ = cljs.core.ex_data(error);\nif(cljs.core.truth_(temp__5825__auto__)){\nvar data = temp__5825__auto__;\nreturn taoensso.truss.submap_QMARK_(data,pattern);\n} else {\nreturn null;\n}\n} else {\nreturn taoensso.truss.unexpected_arg_BANG__STAR_(\"taoensso.truss\",new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [427,17], null),pattern,new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"param\",\"param\",2013631823),new cljs.core.Symbol(null,\"pattern\",\"pattern\",1882666950,null),new cljs.core.Keyword(null,\"context\",\"context\",-830191113),new cljs.core.Symbol(\"taoensso.truss\",\"matching-error\",\"taoensso.truss/matching-error\",557680092,null),new cljs.core.Keyword(null,\"expected\",\"expected\",1583670997),new cljs.core.PersistentHashSet(null, new cljs.core.PersistentArrayMap(null, 5, [null,\"null\",new cljs.core.Symbol(null,\"set\",\"set\",1945134081,null),\"null\",new cljs.core.Symbol(null,\"map\",\"map\",-1282745308,null),\"null\",new cljs.core.Symbol(null,\"re-pattern\",\"re-pattern\",1047705161,null),\"null\",new cljs.core.Symbol(null,\"string\",\"string\",-349010059,null),\"null\"], null), null)], null));\n\n}\n}\n}\n}\n}\n} else {\nreturn and__5140__auto__;\n}\n})();\nif(cljs.core.truth_(temp__5823__auto__)){\nvar match_QMARK_ = temp__5823__auto__;\nreturn error;\n} else {\nvar temp__5825__auto__ = cljs.core.ex_cause(error);\nif(cljs.core.truth_(temp__5825__auto__)){\nvar cause = temp__5825__auto__;\nreturn taoensso.truss.matching_error.cljs$core$IFn$_invoke$arity$3(kind,pattern,cause);\n} else {\nreturn null;\n}\n}\n}));\n\n(taoensso.truss.matching_error.cljs$lang$maxFixedArity = 3);\n\nvar get_default_error_fn_22999 = (function (base_data){\nvar msg = cljs.core.get.cljs$core$IFn$_invoke$arity$3(base_data,new cljs.core.Keyword(\"error\",\"msg\",\"error/msg\",-1549923468),\"Error thrown during reduction\");\nvar base_data__$1 = cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(base_data,new cljs.core.Keyword(\"error\",\"msg\",\"error/msg\",-1549923468));\nreturn (function taoensso$truss$default_error_fn(data,cause){\nthrow taoensso.truss.ex_info_STAR_(\"taoensso.truss\",new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [470,20], null),msg,cljs.core.conj.cljs$core$IFn$_invoke$arity$2(base_data__$1,data),cause);\n});\n});\n/**\n * Returns wrapper around given reducing function `rf` so that if `rf`\n *  throws, (error-fn <thrown-error> <contextual-data>) will be called.\n * \n *  The default `error-fn` will rethrow the original error, wrapped in\n *  extra contextual information to aid debugging.\n * \n *  Helps make reducing fns easier to debug!\n *  See also `catching-xform`.\n */\ntaoensso.truss.catching_rf = (function taoensso$truss$catching_rf(var_args){\nvar G__22868 = arguments.length;\nswitch (G__22868) {\ncase 1:\nreturn taoensso.truss.catching_rf.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn taoensso.truss.catching_rf.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",arguments.length].join(\"\")));\n\n}\n});\n\n(taoensso.truss.catching_rf.cljs$core$IFn$_invoke$arity$1 = (function (rf){\nreturn taoensso.truss.catching_rf.cljs$core$IFn$_invoke$arity$2(get_default_error_fn_22999(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"rf\",\"rf\",2002878243),rf], null)),rf);\n}));\n\n(taoensso.truss.catching_rf.cljs$core$IFn$_invoke$arity$2 = (function (error_fn,rf){\nvar error_fn__$1 = ((cljs.core.map_QMARK_(error_fn))?get_default_error_fn_22999(error_fn):error_fn);\nreturn (function() {\nvar taoensso$truss$catching_rf = null;\nvar taoensso$truss$catching_rf__0 = (function (){\ntry{return (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n}catch (e22880){var t = e22880;\nvar G__22882 = new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"rf\",\"rf\",2002878243),rf,new cljs.core.Keyword(null,\"call\",\"call\",-519999866),cljs.core.list(new cljs.core.Symbol(null,\"rf\",\"rf\",-651557526,null))], null);\nvar G__22883 = t;\nreturn (error_fn__$1.cljs$core$IFn$_invoke$arity$2 ? error_fn__$1.cljs$core$IFn$_invoke$arity$2(G__22882,G__22883) : error_fn__$1.call(null,G__22882,G__22883));\n}});\nvar taoensso$truss$catching_rf__1 = (function (acc){\ntry{return (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(acc) : rf.call(null,acc));\n}catch (e22884){var t = e22884;\nvar G__22885 = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"rf\",\"rf\",2002878243),rf,new cljs.core.Keyword(null,\"call\",\"call\",-519999866),cljs.core.list(new cljs.core.Symbol(null,\"rf\",\"rf\",-651557526,null),new cljs.core.Symbol(null,\"acc\",\"acc\",-1815869457,null)),new cljs.core.Keyword(null,\"args\",\"args\",1315556576),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"acc\",\"acc\",838566312),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"value\",\"value\",305978217),acc,new cljs.core.Keyword(null,\"type\",\"type\",1174270348),cljs.core.type(acc)], null)], null)], null);\nvar G__22886 = t;\nreturn (error_fn__$1.cljs$core$IFn$_invoke$arity$2 ? error_fn__$1.cljs$core$IFn$_invoke$arity$2(G__22885,G__22886) : error_fn__$1.call(null,G__22885,G__22886));\n}});\nvar taoensso$truss$catching_rf__2 = (function (acc,in$){\ntry{return (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(acc,in$) : rf.call(null,acc,in$));\n}catch (e22889){var t = e22889;\nvar G__22890 = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"rf\",\"rf\",2002878243),rf,new cljs.core.Keyword(null,\"call\",\"call\",-519999866),cljs.core.list(new cljs.core.Symbol(null,\"rf\",\"rf\",-651557526,null),new cljs.core.Symbol(null,\"acc\",\"acc\",-1815869457,null),new cljs.core.Symbol(null,\"in\",\"in\",109346662,null)),new cljs.core.Keyword(null,\"args\",\"args\",1315556576),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"acc\",\"acc\",838566312),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"value\",\"value\",305978217),acc,new cljs.core.Keyword(null,\"type\",\"type\",1174270348),cljs.core.type(acc)], null),new cljs.core.Keyword(null,\"in\",\"in\",-1531184865),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"value\",\"value\",305978217),in$,new cljs.core.Keyword(null,\"type\",\"type\",1174270348),cljs.core.type(in$)], null)], null)], null);\nvar G__22891 = t;\nreturn (error_fn__$1.cljs$core$IFn$_invoke$arity$2 ? error_fn__$1.cljs$core$IFn$_invoke$arity$2(G__22890,G__22891) : error_fn__$1.call(null,G__22890,G__22891));\n}});\nvar taoensso$truss$catching_rf__3 = (function (acc,k,v){\ntry{return (rf.cljs$core$IFn$_invoke$arity$3 ? rf.cljs$core$IFn$_invoke$arity$3(acc,k,v) : rf.call(null,acc,k,v));\n}catch (e22892){var t = e22892;\nvar G__22893 = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"rf\",\"rf\",2002878243),rf,new cljs.core.Keyword(null,\"call\",\"call\",-519999866),cljs.core.list(new cljs.core.Symbol(null,\"rf\",\"rf\",-651557526,null),new cljs.core.Symbol(null,\"acc\",\"acc\",-1815869457,null),new cljs.core.Symbol(null,\"k\",\"k\",-505765866,null),new cljs.core.Symbol(null,\"v\",\"v\",1661996586,null)),new cljs.core.Keyword(null,\"args\",\"args\",1315556576),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"acc\",\"acc\",838566312),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"value\",\"value\",305978217),acc,new cljs.core.Keyword(null,\"type\",\"type\",1174270348),cljs.core.type(acc)], null),new cljs.core.Keyword(null,\"k\",\"k\",-2146297393),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"value\",\"value\",305978217),k,new cljs.core.Keyword(null,\"type\",\"type\",1174270348),cljs.core.type(k)], null),new cljs.core.Keyword(null,\"v\",\"v\",21465059),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"value\",\"value\",305978217),v,new cljs.core.Keyword(null,\"type\",\"type\",1174270348),cljs.core.type(v)], null)], null)], null);\nvar G__22894 = t;\nreturn (error_fn__$1.cljs$core$IFn$_invoke$arity$2 ? error_fn__$1.cljs$core$IFn$_invoke$arity$2(G__22893,G__22894) : error_fn__$1.call(null,G__22893,G__22894));\n}});\ntaoensso$truss$catching_rf = function(acc,k,v){\nswitch(arguments.length){\ncase 0:\nreturn taoensso$truss$catching_rf__0.call(this);\ncase 1:\nreturn taoensso$truss$catching_rf__1.call(this,acc);\ncase 2:\nreturn taoensso$truss$catching_rf__2.call(this,acc,k);\ncase 3:\nreturn taoensso$truss$catching_rf__3.call(this,acc,k,v);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\ntaoensso$truss$catching_rf.cljs$core$IFn$_invoke$arity$0 = taoensso$truss$catching_rf__0;\ntaoensso$truss$catching_rf.cljs$core$IFn$_invoke$arity$1 = taoensso$truss$catching_rf__1;\ntaoensso$truss$catching_rf.cljs$core$IFn$_invoke$arity$2 = taoensso$truss$catching_rf__2;\ntaoensso$truss$catching_rf.cljs$core$IFn$_invoke$arity$3 = taoensso$truss$catching_rf__3;\nreturn taoensso$truss$catching_rf;\n})()\n}));\n\n(taoensso.truss.catching_rf.cljs$lang$maxFixedArity = 2);\n\n/**\n * Like `catching-rf`, but applies to a transducer (`xform`).\n * \n *   Helps make transductions much easier to debug by greatly improving\n *   the info provided in any errors thrown by `xform` or the reducing fn:\n * \n *  (transduce\n *    (catching-xform (comp (filter even?) (map inc))) ; Modified xform\n *    <reducing-fn>\n *    <...>)\n */\ntaoensso.truss.catching_xform = (function taoensso$truss$catching_xform(var_args){\nvar G__22898 = arguments.length;\nswitch (G__22898) {\ncase 2:\nreturn taoensso.truss.catching_xform.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 1:\nreturn taoensso.truss.catching_xform.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",arguments.length].join(\"\")));\n\n}\n});\n\n(taoensso.truss.catching_xform.cljs$core$IFn$_invoke$arity$2 = (function (error_fn,xform){\nreturn cljs.core.comp.cljs$core$IFn$_invoke$arity$2((function (rf){\nreturn taoensso.truss.catching_rf.cljs$core$IFn$_invoke$arity$2(error_fn,rf);\n}),xform);\n}));\n\n(taoensso.truss.catching_xform.cljs$core$IFn$_invoke$arity$1 = (function (xform){\nreturn cljs.core.comp.cljs$core$IFn$_invoke$arity$2(taoensso.truss.catching_rf,xform);\n}));\n\n(taoensso.truss.catching_xform.cljs$lang$maxFixedArity = 2);\n\ntaoensso.truss.sys_newline = \"\\n\";\nvar legacy_ex_data_QMARK__23031 = false;\n/**\n * Returns an appropriate `truss/ex-info` for given failed assertion info map.\n */\ntaoensso.truss.failed_assertion_ex_info = (function taoensso$truss$failed_assertion_ex_info(var_args){\nvar G__22906 = arguments.length;\nswitch (G__22906) {\ncase 1:\nreturn taoensso.truss.failed_assertion_ex_info.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn taoensso.truss.failed_assertion_ex_info.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",arguments.length].join(\"\")));\n\n}\n});\n\n(taoensso.truss.failed_assertion_ex_info.cljs$core$IFn$_invoke$arity$1 = (function (failed_assertion_info){\nreturn taoensso.truss.failed_assertion_ex_info.cljs$core$IFn$_invoke$arity$2(legacy_ex_data_QMARK__23031,failed_assertion_info);\n}));\n\n(taoensso.truss.failed_assertion_ex_info.cljs$core$IFn$_invoke$arity$2 = (function (legacy_ex_data_QMARK___$1,failed_assertion_info){\nvar map__22907 = failed_assertion_info;\nvar map__22907__$1 = cljs.core.__destructure_map(map__22907);\nvar inst = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__22907__$1,new cljs.core.Keyword(null,\"inst\",\"inst\",645962501));\nvar ns = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__22907__$1,new cljs.core.Keyword(null,\"ns\",\"ns\",441598760));\nvar coords = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__22907__$1,new cljs.core.Keyword(null,\"coords\",\"coords\",-599429112));\nvar pred = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__22907__$1,new cljs.core.Keyword(null,\"pred\",\"pred\",1927423397));\nvar arg_form = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__22907__$1,new cljs.core.Keyword(null,\"arg-form\",\"arg-form\",1400564013));\nvar arg_val = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__22907__$1,new cljs.core.Keyword(null,\"arg-val\",\"arg-val\",1802419280));\nvar data = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__22907__$1,new cljs.core.Keyword(null,\"data\",\"data\",-232669377));\nvar error = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__22907__$1,new cljs.core.Keyword(null,\"error\",\"error\",-978969032));\nvar undefined_arg_QMARK_ = cljs.core.keyword_identical_QMARK_(arg_val,new cljs.core.Keyword(\"truss\",\"exception\",\"truss/exception\",1369199181));\nvar coords_str = (function (){var temp__5825__auto__ = coords;\nif(cljs.core.truth_(temp__5825__auto__)){\nvar vec__22908 = temp__5825__auto__;\nvar line = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__22908,(0),null);\nvar column = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__22908,(1),null);\nif(cljs.core.truth_(column)){\nreturn (\"\"+\"[\"+cljs.core.str.cljs$core$IFn$_invoke$arity$1(line)+\",\"+cljs.core.str.cljs$core$IFn$_invoke$arity$1(column)+\"]\");\n} else {\nreturn (\"\"+\"[\"+cljs.core.str.cljs$core$IFn$_invoke$arity$1(line)+\"]\");\n}\n} else {\nreturn null;\n}\n})();\nvar msg = (\"\"+\"Truss assertion failed at \"+cljs.core.str.cljs$core$IFn$_invoke$arity$1(ns)+cljs.core.str.cljs$core$IFn$_invoke$arity$1(coords_str)+\": \"+cljs.core.str.cljs$core$IFn$_invoke$arity$1((new cljs.core.List(null,pred,(new cljs.core.List(null,arg_form,null,(1),null)),(2),null))));\nvar msg__$1 = (cljs.core.truth_(error)?(function (){var error_msg = cljs.core.ex_message(error);\nif(undefined_arg_QMARK_){\nreturn (\"\"+cljs.core.str.cljs$core$IFn$_invoke$arity$1(msg)+cljs.core.str.cljs$core$IFn$_invoke$arity$1(taoensso.truss.sys_newline)+\"Error evaluating arg: \"+cljs.core.str.cljs$core$IFn$_invoke$arity$1(error_msg));\n} else {\nreturn (\"\"+cljs.core.str.cljs$core$IFn$_invoke$arity$1(msg)+cljs.core.str.cljs$core$IFn$_invoke$arity$1(taoensso.truss.sys_newline)+\"Error evaluating pred: \"+cljs.core.str.cljs$core$IFn$_invoke$arity$1(error_msg));\n}\n})():msg);\nreturn taoensso.truss.ex_info_STAR_(\"taoensso.truss\",new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [547,8], null),msg__$1,(cljs.core.truth_(legacy_ex_data_QMARK___$1)?new cljs.core.PersistentArrayMap(null, 8, [new cljs.core.Keyword(null,\"dt\",\"dt\",-368444759),(new Date()),new cljs.core.Keyword(null,\"loc\",\"loc\",-584284901),(function (){var vec__22913 = coords;\nvar line = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__22913,(0),null);\nvar column = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__22913,(1),null);\nreturn new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"ns\",\"ns\",441598760),ns,new cljs.core.Keyword(null,\"line\",\"line\",212345235),line,new cljs.core.Keyword(null,\"column\",\"column\",2078222095),column], null);\n})(),new cljs.core.Keyword(null,\"msg\",\"msg\",-1386103444),msg__$1,new cljs.core.Keyword(null,\"pred\",\"pred\",1927423397),pred,new cljs.core.Keyword(null,\"data\",\"data\",-232669377),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"arg\",\"arg\",-1747261837),data,new cljs.core.Keyword(null,\"dynamic\",\"dynamic\",704819571),taoensso.truss._STAR_ctx_STAR_], null),new cljs.core.Keyword(null,\"env\",\"env\",-1815813235),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"*assert*\",\"*assert*\",-160895053),cljs.core._STAR_assert_STAR_], null),new cljs.core.Keyword(null,\"error\",\"error\",-978969032),error,new cljs.core.Keyword(null,\"arg\",\"arg\",-1747261837),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"form\",\"form\",-1624062471),arg_form,new cljs.core.Keyword(null,\"value\",\"value\",305978217),arg_val,new cljs.core.Keyword(null,\"type\",\"type\",1174270348),((undefined_arg_QMARK_)?new cljs.core.Keyword(\"truss\",\"exception\",\"truss/exception\",1369199181):cljs.core.type(arg_val))], null)], null):taoensso.truss.impl.assoc_some.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\"inst\",\"inst\",645962501),(new Date()),new cljs.core.Keyword(null,\"ns\",\"ns\",441598760),ns,new cljs.core.Keyword(null,\"pred\",\"pred\",1927423397),pred,new cljs.core.Keyword(null,\"arg\",\"arg\",-1747261837),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"form\",\"form\",-1624062471),arg_form,new cljs.core.Keyword(null,\"value\",\"value\",305978217),arg_val,new cljs.core.Keyword(null,\"type\",\"type\",1174270348),((undefined_arg_QMARK_)?new cljs.core.Keyword(\"truss\",\"exception\",\"truss/exception\",1369199181):cljs.core.type(arg_val))], null)], null),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"coords\",\"coords\",-599429112),coords,new cljs.core.Keyword(null,\"data\",\"data\",-232669377),data], null))),error);\n}));\n\n(taoensso.truss.failed_assertion_ex_info.cljs$lang$maxFixedArity = 2);\n\n/**\n * Unary handler fn to call with failed assertion info map when a Truss\n *   assertion (`have`, `have?`, `have!`, `have!?`) fails.\n * \n *   Will by default throw an appropriate `truss/ex-info`.\n *   This is a decent place to inject logging for assertion failures, etc.\n * \n *   Arg given to handler is a map with keys:\n * \n *   `:ns` ----------- ?str namespace of assertion callsite\n *   `:coords` ------- ?[line column] of assertion callsite\n * \n *   `:pred` --------- Assertion predicate form  (e.g. `clojure.core/string?` sym)\n *   `:arg-form` ----- Assertion argument  form given  to predicate (e.g. `x` sym)\n *   `:arg-val` ------ Runtime value of argument given to predicate\n * \n *   `:data` --------- Optional arbitrary data map provided to assertion macro\n *   `:error` -------- `Throwable` or `js/Error` thrown evaluating predicate\n */\ntaoensso.truss._STAR_failed_assertion_handler_STAR_ = (function taoensso$truss$_STAR_failed_assertion_handler_STAR_(failed_assertion_info){\nthrow taoensso.truss.failed_assertion_ex_info.cljs$core$IFn$_invoke$arity$1(failed_assertion_info);\n});\n/**\n * Private, don't use.\n */\ntaoensso.truss.failed_assertion_BANG_ = (function taoensso$truss$failed_assertion_BANG_(ns,line,column,pred,arg_form,arg_val,data_fn,error){\nvar temp__5823__auto__ = taoensso.truss._STAR_failed_assertion_handler_STAR_;\nif(cljs.core.truth_(temp__5823__auto__)){\nvar handler = temp__5823__auto__;\nvar G__22923 = (function (){var undefined_arg_QMARK_ = (arg_val instanceof taoensso.truss.impl.ArgEvalError);\nreturn (new taoensso.truss.impl.FailedAssertionInfo(ns,(cljs.core.truth_(line)?(cljs.core.truth_(column)?new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [line,column], null):new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [line], null)):null),pred,arg_form,((undefined_arg_QMARK_)?new cljs.core.Keyword(\"truss\",\"exception\",\"truss/exception\",1369199181):arg_val),(function (){var temp__5825__auto__ = data_fn;\nif(cljs.core.truth_(temp__5825__auto__)){\nvar df = temp__5825__auto__;\ntry{return (df.cljs$core$IFn$_invoke$arity$0 ? df.cljs$core$IFn$_invoke$arity$0() : df.call(null));\n}catch (e22925){var _ = e22925;\nreturn new cljs.core.Keyword(\"truss\",\"exception\",\"truss/exception\",1369199181);\n}} else {\nreturn null;\n}\n})(),(((error === taoensso.truss.impl.FalsePredError))?null:((undefined_arg_QMARK_)?error.ex:error\n)),null,null,null));\n})();\nreturn (handler.cljs$core$IFn$_invoke$arity$1 ? handler.cljs$core$IFn$_invoke$arity$1(G__22923) : handler.call(null,G__22923));\n} else {\nreturn arg_val;\n}\n});\n/**\n * Private, don't use. Wraps given Truss v1 `error-fn` to convert\n *   Truss v2 `*failed-assertion-handler*` arg.\n */\ntaoensso.truss.legacy_error_fn = (function taoensso$truss$legacy_error_fn(f){\nif(cljs.core.truth_(f)){\nreturn (function (failed_assertion_info){\nvar G__22941 = (new cljs.core.Delay((function (){\nvar map__22945 = failed_assertion_info;\nvar map__22945__$1 = cljs.core.__destructure_map(map__22945);\nvar ns = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__22945__$1,new cljs.core.Keyword(null,\"ns\",\"ns\",441598760));\nvar coords = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__22945__$1,new cljs.core.Keyword(null,\"coords\",\"coords\",-599429112));\nvar pred = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__22945__$1,new cljs.core.Keyword(null,\"pred\",\"pred\",1927423397));\nvar arg_form = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__22945__$1,new cljs.core.Keyword(null,\"arg-form\",\"arg-form\",1400564013));\nvar arg_val = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__22945__$1,new cljs.core.Keyword(null,\"arg-val\",\"arg-val\",1802419280));\nvar data = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__22945__$1,new cljs.core.Keyword(null,\"data\",\"data\",-232669377));\nvar error = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__22945__$1,new cljs.core.Keyword(null,\"error\",\"error\",-978969032));\nvar vec__22946 = coords;\nvar line = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__22946,(0),null);\nvar column = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__22946,(1),null);\nvar msg_ = (new cljs.core.Delay((function (){\nvar msg = (\"\"+\"Invariant failed at \"+cljs.core.str.cljs$core$IFn$_invoke$arity$1(ns)+cljs.core.str.cljs$core$IFn$_invoke$arity$1((cljs.core.truth_(line)?(\"\"+\"[\"+cljs.core.str.cljs$core$IFn$_invoke$arity$1(line)+cljs.core.str.cljs$core$IFn$_invoke$arity$1((cljs.core.truth_(column)?(\"\"+\",\"+cljs.core.str.cljs$core$IFn$_invoke$arity$1(column)):null))+\"]\"):null))+\": \"+cljs.core.str.cljs$core$IFn$_invoke$arity$1((new cljs.core.List(null,pred,(new cljs.core.List(null,arg_form,null,(1),null)),(2),null))));\nif(cljs.core.truth_(error)){\nvar error_msg = cljs.core.ex_message(error);\nif(cljs.core.keyword_identical_QMARK_(arg_val,new cljs.core.Keyword(\"truss\",\"exception\",\"truss/exception\",1369199181))){\nreturn (\"\"+cljs.core.str.cljs$core$IFn$_invoke$arity$1(msg)+cljs.core.str.cljs$core$IFn$_invoke$arity$1(taoensso.truss.sys_newline)+cljs.core.str.cljs$core$IFn$_invoke$arity$1(taoensso.truss.sys_newline)+\"Error evaluating arg: \"+cljs.core.str.cljs$core$IFn$_invoke$arity$1(error_msg));\n} else {\nreturn (\"\"+cljs.core.str.cljs$core$IFn$_invoke$arity$1(msg)+cljs.core.str.cljs$core$IFn$_invoke$arity$1(taoensso.truss.sys_newline)+cljs.core.str.cljs$core$IFn$_invoke$arity$1(taoensso.truss.sys_newline)+\"Error evaluating pred: \"+cljs.core.str.cljs$core$IFn$_invoke$arity$1(error_msg));\n}\n} else {\nreturn msg;\n}\n}),null));\nreturn taoensso.truss.impl.assoc_some.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\"msg_\",\"msg_\",-1925147000),msg_,new cljs.core.Keyword(null,\"dt\",\"dt\",-368444759),(new Date()),new cljs.core.Keyword(null,\"pred\",\"pred\",1927423397),pred,new cljs.core.Keyword(null,\"arg\",\"arg\",-1747261837),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"form\",\"form\",-1624062471),arg_form,new cljs.core.Keyword(null,\"value\",\"value\",305978217),arg_val,new cljs.core.Keyword(null,\"type\",\"type\",1174270348),cljs.core.type(arg_val)], null),new cljs.core.Keyword(null,\"env\",\"env\",-1815813235),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"*assert*\",\"*assert*\",-160895053),cljs.core._STAR_assert_STAR_], null),new cljs.core.Keyword(null,\"loc\",\"loc\",-584284901),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"ns\",\"ns\",441598760),ns,new cljs.core.Keyword(null,\"line\",\"line\",212345235),line,new cljs.core.Keyword(null,\"column\",\"column\",2078222095),column], null)], null),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"data\",\"data\",-232669377),taoensso.truss.impl.assoc_some.cljs$core$IFn$_invoke$arity$2(null,new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"dynamic\",\"dynamic\",704819571),taoensso.truss._STAR_ctx_STAR_,new cljs.core.Keyword(null,\"arg\",\"arg\",-1747261837),data], null)),new cljs.core.Keyword(null,\"err\",\"err\",-2089457205),error], null));\n}),null));\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__22941) : f.call(null,G__22941));\n});\n} else {\nreturn null;\n}\n});\n/**\n * Prefer `*ctx*`\n */\ntaoensso.truss.get_dynamic_assertion_data = (function taoensso$truss$get_dynamic_assertion_data(){\nreturn taoensso.truss._STAR_ctx_STAR_;\n});\n/**\n * Prefer `*ctx*`\n */\ntaoensso.truss.get_data = (function taoensso$truss$get_data(){\nreturn taoensso.truss._STAR_ctx_STAR_;\n});\n/**\n * Prefer `*failed-assertion-handler*` (note breaking changes to argument).\n */\ntaoensso.truss.set_error_fn_BANG_ = (function taoensso$truss$set_error_fn_BANG_(f){\nreturn (taoensso.truss._STAR_failed_assertion_handler_STAR_ = taoensso.truss.legacy_error_fn(f));\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:author","Peter Taoussanis (@ptaoussanis)","~:doc","A micro toolkit for Clojure/Script errors.","~:file","taoensso/truss.cljc","~:line",1,"~:column",5,"~:end-line",1,"~:end-column",19],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$clojure.spec.alpha","~$cljs.spec.alpha","~$clojure.pprint","~$cljs.pprint","~$clojure.core.async","~$cljs.core.async"],"~:use-macros",["^ ","~$try*","~$taoensso.truss","~$with-dynamic-assertion-data","^H","~$throws?","^H","~$with-ctx+","^H","~$typed-val","^H","~$have","^H","~$keep-callsite","^H","~$have!","^H","~$throws","^H","~$unexpected-arg!","^H","~$have?","^H","~$ex-info!","^H","~$ex-info","^H","~$with-data","^H","~$catching","^H","~$have!?","^H","~$with-error-fn","^H","~$with-ctx","^H"],"~:excludes",["~#set",["^T"]],"~:macros",["^ ","^G",["^ ","~:arglists",["~#list",[["~$expr*","~$catch-clauses*","~$?finally-clause"]]],"^7","Like `try`, but `catch` clause class may be:\n       `:ex-info` -- Catches only `ExceptionInfo`\n       `:common` --- Catches `js/Error` (Cljs), `Exception` (Clj)\n       `:all` ------ Catches `:default` (Cljs), `Throwable` (Clj)\n       `:default` -- Catches `:default` (Cljs), `Exception`, and `AssertionError` (Clj)\n                     but NOT other (usually critical) `Error`s\n\n     Addresses CLJ-1293 and the fact that `AssertionError`s are typically NON-critical\n     (so desirable to catch, in contrast to other `Error` classes).","^9",316,"^:",4,"^8","taoensso/truss.cljc","~:name","~$taoensso.truss/try*","~:ns","^H","~:macro",true],"^I",["^ ","~:no-doc",true,"^18","^H","^16","~$taoensso.truss/with-dynamic-assertion-data","^8","taoensso/truss.cljc","^:",9,"^9",724,"^19",true,"~:deprecated",true,"^11",["^12",[["~$data","~$&","~$body"]]],"^7","Prefer `*ctx*`"],"^J",["^ ","^11",["^12",[["~$form"],["~$kind","^1?"],["^1@","~$pattern","^1?"]]],"^7","Evals `form` and if it throws an error that matches given criteria using\n     `matching-error`, returns true. Otherwise returns false.\n\n     Useful for unit tests, e.g.:\n       (is (throws? :default {:a :b}  (throw (ex-info \"MyEx\" {:a :b, :c :d})))) ; => true\n       (is (throws? :default \"MyEx\" (throw (ex-info \"MyEx\" {:a :b, :c :d})))) ; => true\n\n     See also `throws`, `matching-error`.","^9",451,"^:",4,"^8","taoensso/truss.cljc","^16","~$taoensso.truss/throws?","^18","^H","^19",true],"^K",["^ ","^11",["^12",[["~$update-map-or-fn","~$&","^1>"]]],"^7","Evaluates given body with updated `*ctx*` value.\n\n  `update-map-or-fn` may be:\n    - A map to merge with    current `*ctx*` value, or\n    - A unary fn to apply to current `*ctx*` value\n\n  See `*ctx*` for details.","^9",199,"^:",1,"^8","taoensso/truss.cljc","^16","~$taoensso.truss/with-ctx+","^18","^H","^19",true],"^L",["^ ","^1:",true,"^11",["^12",[["~$x"]]],"^9",58,"^:",9,"^8","taoensso/truss.cljc","^16","~$taoensso.truss/typed-val","^18","^H","^19",true],"^M",["^ ","^11",["^12",[["~$x"],["~$pred",["^12",["~:in"]],"~$x"],["^1F",["^12",["^1G"]],"~$x","~$&","~$more-xs"]]],"^7","Main Truss assertion util.\n     Takes a (fn pred [x]) => truthy, and >=1 vals.\n     Tests pred against each val,trapping errors.\n\n     If any pred test fails, throws a detailed `truss/ex-info`.\n     Otherwise returns input val/s for convenient inline-use/binding.\n\n     Respects `*assert*`, so tests can be elided from production if desired\n     (meaning zero runtime cost).\n\n     Examples:\n       (defn my-trim [x] (str/trim (have string? x)))\n\n       ;; Add arb optional info to thrown ex-data using `:data`:\n       (have string? \"foo\" :data {:user-id 101}) => \"foo\"\n\n       ;; Assert inside collections using `:in`:\n       (have string? :in #{\"foo\" \"bar\"}) => #{\"foo\" \"bar\"}\n\n     Regarding use within other macros:\n       Due to CLJ-865, callsite info like line number of outer macro\n       will be lost. See `keep-callsite` for workaround.\n\n     See also `have?`, `have!`.","^9",620,"^:",4,"^8","taoensso/truss.cljc","^16","~$taoensso.truss/have","^18","^H","^19",true],"^N",["^ ","^11",["^12",[["~$inner-form"]]],"^7","CLJ-865 means that it's not possible for an inner macro to access `&form`\n     metadata (incl. {:keys [line column]}) of a wrapping outer macro:\n\n       (defmacro inner [] (meta &form))\n       (defmacro outer [] `(inner))\n       (outer) => nil\n\n     This util offers a workaround for authors of the outer macro, preserving\n     the outer `&form` metadata for the inner macro:\n\n       (defmacro inner [] (meta &form))\n       (defmacro outer [] (keep-callsite `(inner)))\n       (outer) => {:keys [line column ...]}","^9",40,"^:",4,"^8","taoensso/truss.cljc","^16","~$taoensso.truss/keep-callsite","^18","^H","^19",true],"^O",["^ ","^11",["^12",[["~$x"],["^1F",["^12",["^1G"]],"~$x"],["^1F",["^12",["^1G"]],"~$x","~$&","^1H"]]],"^7","Truss assertion util.\n     Like `have` but ignores `*assert*` value (so will never be elided).\n     Useful for important conditions in production (e.g. security checks).","^9",659,"^:",4,"^8","taoensso/truss.cljc","^16","~$taoensso.truss/have!","^18","^H","^19",true],"^P",["^ ","^11",["^12",[["^1?"],["^1@","^1?"],["^1@","^1A","^1?"]]],"^7","Evals `form` and if it throws an error that matches given criteria using\n     `matching-error`, returns the matching error. Otherwise returns nil.\n\n     Useful for unit tests, e.g.:\n       (is (throws :default {:a :b}  (throw (ex-info \"MyEx\" {:a :b, :c :d})))) ; => ExceptionInfo\n       (is (throws :default \"MyEx\" (throw (ex-info \"MyEx\" {:a :b, :c :d})))) ; => ExceptionInfo\n\n     See also `throws?`, `matching-error`.","^9",437,"^:",4,"^8","taoensso/truss.cljc","^16","~$taoensso.truss/throws","^18","^H","^19",true],"^Q",["^ ","^11",["^12",[["~$arg"],["^1N","~$kvs"]]],"^7","Throws a `truss/ex-info` to indicate an unexpected argument:\n\n       (defn my-function [mode]\n         (case mode\n           :read  (do <...>)\n           :write (do <...>)\n           (unexpected-arg! mode\n             {:param       'mode\n              :context  `my-function\n              :expected #{:read :write}})))\n\n       (my-function :invalid-mode) => throws\n         Unexpected argument: :invalid-mode\n         {:param 'mode,\n          :arg {:value :unexpected, :type clojure.lang.Keyword},\n          :context 'my-ns/my-function,\n          :expected #{:read :write}\n          ...}","^9",149,"^:",4,"^8","taoensso/truss.cljc","^16","~$taoensso.truss/unexpected-arg!","^18","^H","^19",true],"^R",["^ ","^11",["^12",[["~$x"],["^1F",["^12",["^1G"]],"~$x"],["^1F",["^12",["^1G"]],"~$x","~$&","^1H"]]],"^7","Truss assertion util.\n     Like `have` but returns `true` (rather than given arg value) on success.\n     Handy for `:pre`/`:post` conditions. Compare:\n       ((fn my-fn [] {:post [(have  nil? %)]} nil)) ; {:post [nil ]} FAILS\n       ((fn my-fn [] {:post [(have? nil? %)]} nil)) ; {:post [true]} passes as intended","^9",649,"^:",4,"^8","taoensso/truss.cljc","^16","~$taoensso.truss/have?","^18","^H","^19",true],"^S",["^ ","^11",["^12",[["~$msg"],["^1R","~$data-map"],["^1R","^1S","~$cause"]]],"^7","Throws a `truss/ex-info`.","^9",142,"^:",4,"^8","taoensso/truss.cljc","^16","~$taoensso.truss/ex-info!","^18","^H","^19",true],"^T",["^ ","^11",["^12",[["^1R"],["^1R","^1S"],["^1R","^1S","^1T"]]],"^7","Macro version of `core/ex-info` that adds extra keys to ex-info's data map:\n       `:truss/ctx` -- Value of dynamic `truss/*ctx*` when ex-info created\n       `:ns` --------- Namespace string of ex-info callsite\n       `:coords` ----- [line number]    of ex-info callsite, only present\n                       if ex-info isn't wrapped by another macro (or see\n                      `keep-callsite` for a workaround).","^9",130,"^:",4,"^8","taoensso/truss.cljc","^16","~$taoensso.truss/ex-info","^18","^H","^19",true],"^U",["^ ","^1:",true,"^18","^H","^16","~$taoensso.truss/with-data","^8","taoensso/truss.cljc","^:",9,"^9",725,"^19",true,"^1<",true,"^11",["^12",[["^1=","~$&","^1>"]]],"^7","Prefer `*ctx*`"],"^V",["^ ","^11",["^12",[["~$expr"],["~$catch-class","^1X"]]],"^7","Terse cross-platform util to swallow exceptions in `expr`.\n     Like (try* expr (catch :default _ nil)). See also `try*`.","^9",367,"^:",4,"^8","taoensso/truss.cljc","^16","~$taoensso.truss/catching","^18","^H","^19",true],"^W",["^ ","^11",["^12",[["~$x"],["^1F",["^12",["^1G"]],"~$x"],["^1F",["^12",["^1G"]],"~$x","~$&","^1H"]]],"^7","Truss assertion util.\n     Returns `true` (rather than given arg value) on success, and ignores\n     `*assert*` value (so will never be elided).\n  \n     **WARNING**: do NOT use in `:pre`/`:post` conditions since those ALWAYS\n     respect `*assert*`, contradicting the intention of the bang (`!`) here.","^9",667,"^:",4,"^8","taoensso/truss.cljc","^16","~$taoensso.truss/have!?","^18","^H","^19",true],"^X",["^ ","^1:",true,"^18","^H","^16","~$taoensso.truss/with-error-fn","^8","taoensso/truss.cljc","^:",4,"^9",727,"^19",true,"^1<",true,"^11",["^12",[["~$f","~$&","^1>"]]],"^7","Prefer `*failed-assertion-handler*` (note breaking changes to argument)."],"^Y",["^ ","^11",["^12",[["~$ctx-val","~$&","^1>"]]],"^7","Evaluates given body with given `*ctx*` value. See `*ctx*` for details.","^9",182,"^:",1,"^8","taoensso/truss.cljc","^16","~$taoensso.truss/with-ctx","^18","^H","^19",true]],"^16","^H","~:reader-aliases",["^ "],"~:op","^18","~:imports",null,"~:requires",["^ ","~$cljs.core","^27","~$core","^27","~$taoensso.truss.impl","^29","~$impl","^29","~$goog","^2;"],"~:seen",["^[",["~:require","~:require-macros"]],"~:uses",["^ ","~$FailedAssertionInfo","^29","~$ArgEvalError","^29"],"^2>",["^ ","^H","^H","^27","^27","^28","^27","^29","^29","^2:","^29"],"~:form",["^12",["~$ns","^H","A micro toolkit for Clojure/Script errors.",["^ ","^6","Peter Taoussanis (@ptaoussanis)"],["^12",["~:refer-clojure","~:exclude",["^T"]]],["^12",["^2=",["^27","~:as","^28"],["^29","^2F","^2:","~:refer",["^2@","^2A"]]]],["^12",["^2>",["^H","^2G",["^N","^L","^T","^S","^Q","^Y","^K","^G","^V","^P","^J","^M","^R","^O","^W","^I","^U","^X"]]]]]],"~:flags",["^ ","^2=",["^[",[]],"^2>",["^[",[]]],"~:js-deps",[],"~:deps",["^2;","^27","^29"]],"^18","^H","~:resource-id",["~:shadow.build.classpath/resource","taoensso/truss.cljc"],"~:compiled-at",1770361573525,"^23",["^ ","^27","^27","^28","^27","^29","^29","^2:","^29","^2;","^2;","^H","^H"],"~:resource-name","taoensso/truss.cljc","~:warnings",[],"~:source","(ns taoensso.truss\n  \"A micro toolkit for Clojure/Script errors.\"\n  {:author \"Peter Taoussanis (@ptaoussanis)\"}\n  (:refer-clojure :exclude [ex-info])\n  (:require\n   #?(:clj  [clojure.core :as core]\n      :cljs [cljs.core    :as core])\n\n   #?(:clj  [taoensso.truss.impl :as impl])\n   #?(:cljs [taoensso.truss.impl :as impl :refer [FailedAssertionInfo ArgEvalError]]))\n\n  #?(:cljs\n     (:require-macros\n      [taoensso.truss :refer\n       [keep-callsite typed-val ex-info ex-info! unexpected-arg!\n        with-ctx with-ctx+ try* catching throws throws?\n        have have? have! have!?\n        with-dynamic-assertion-data with-data with-error-fn]]))\n\n  #?(:clj\n     (:import\n      [taoensso.truss.impl FailedAssertionInfo ArgEvalError])))\n\n(comment\n  (require '[taoensso.encore :as enc])\n  (enc/sortv (:api (enc/interns-overview))))\n\n;;;; Callsites\n\n#?(:clj\n   (defn callsite-coords\n     \"Returns [line column] from meta on given macro `&form`.\n     See also `keep-callsite`.\"\n     [macro-form]\n     (when-let [{:keys [line column]} (meta macro-form)]\n       (when line (if column [line column] [line])))))\n\n#?(:clj (defn ^:no-doc merge-callsite [macro-form inner-form] (vary-meta inner-form merge (meta macro-form))))\n#?(:clj\n   (defmacro keep-callsite\n     \"CLJ-865 means that it's not possible for an inner macro to access `&form`\n     metadata (incl. {:keys [line column]}) of a wrapping outer macro:\n\n       (defmacro inner [] (meta &form))\n       (defmacro outer [] `(inner))\n       (outer) => nil\n\n     This util offers a workaround for authors of the outer macro, preserving\n     the outer `&form` metadata for the inner macro:\n\n       (defmacro inner [] (meta &form))\n       (defmacro outer [] (keep-callsite `(inner)))\n       (outer) => {:keys [line column ...]}\"\n     [inner-form] `(merge-callsite ~'&form ~inner-form)))\n\n;;;; Misc\n\n#?(:clj (defmacro ^:no-doc typed-val [x] `{:value ~x, :type (type ~x)}))\n\n(defn ^:no-doc submap?\n  \"Returns true iff `sub-map` is a (possibly nested) submap of `super-map`,\n  i.e. iff every (nested) value in `sub-map` has the same (nested) value in `super-map`.\n\n  `sub-map` may contain special values:\n    `:submap/nx`     - Matches iff `super-map` does not contain key\n    `:submap/ex`     - Matches iff `super-map` does     contain key (any     val)\n    `:submap/some`   - Matches iff `super-map` does     contain key (non-nil val)\n    (fn [super-val]) - Matches iff given unary predicate returns truthy\n\n  Uses stack recursion so supports only limited nesting.\"\n  [super-map sub-map]\n  (reduce-kv\n    (fn [_ sub-key sub-val]\n      (if (map?    sub-val)\n        (let [super-val (get super-map sub-key)]\n          (if-let [match? (and (map? super-val) (submap? super-val sub-val))]\n            true\n            (reduced false)))\n\n        (let [super-val (get super-map sub-key ::nx)]\n          (if-let [match?\n                   (if-let [pred-fn (when (fn? sub-val) sub-val)]\n                     (pred-fn super-val)\n                     (case sub-val\n                       :submap/nx      (impl/identical-kw? super-val ::nx)\n                       :submap/ex (not (impl/identical-kw? super-val ::nx))\n                       :submap/some                 (some? super-val)\n                       (= sub-val super-val)))]\n            true\n            (reduced false)))))\n    true\n    sub-map))\n\n;;;; Truss exceptions\n\n(def ^:dynamic *ctx*\n  \"Context map to assoc to `:truss/ctx` key of `truss/ex-info` data map.\n\n  Re/bind dynamic        value using `with-ctx`, `with-ctx+`, or `binding`.\n  Modify  root (default) value using `set-ctx!`.\n\n  As with all dynamic Clojure vars, \\\"binding conveyance\\\" applies when\n  using futures, agents, etc.\"\n  nil)\n\n(defn ^:no-doc ex-info*\n  \"Private, don't use.\"\n  [ns coords msg data-map cause]\n  (let [data-map\n        (if coords\n          (conj {:ns ns, :coords coords} data-map)\n          (conj {:ns ns}                 data-map))\n\n        data-map\n        (if-let [ctx *ctx*]\n          (assoc data-map :truss/ctx ctx)\n          (do    data-map))]\n\n    (core/ex-info msg data-map cause)))\n\n(defn ^:no-doc unexpected-arg!*\n  \"Private, don't use.\"\n  [ns coords arg kvs]\n  (throw\n    (ex-info* ns coords\n      (or    (get    kvs :msg) (str \"Unexpected argument: \" (if (nil? arg) \"<nil>\" arg)))\n      (assoc (dissoc kvs :msg) :arg (typed-val arg)) nil)))\n\n#?(:clj\n   (defmacro ex-info\n     \"Macro version of `core/ex-info` that adds extra keys to ex-info's data map:\n       `:truss/ctx` -- Value of dynamic `truss/*ctx*` when ex-info created\n       `:ns` --------- Namespace string of ex-info callsite\n       `:coords` ----- [line number]    of ex-info callsite, only present\n                       if ex-info isn't wrapped by another macro (or see\n                      `keep-callsite` for a workaround).\"\n     ([msg               ] `(ex-info* ~(str *ns*) ~(callsite-coords &form) ~msg nil       nil))\n     ([msg data-map      ] `(ex-info* ~(str *ns*) ~(callsite-coords &form) ~msg ~data-map nil))\n     ([msg data-map cause] `(ex-info* ~(str *ns*) ~(callsite-coords &form) ~msg ~data-map ~cause))))\n\n#?(:clj\n   (defmacro ex-info!\n     \"Throws a `truss/ex-info`.\"\n     ([msg               ] `(throw (ex-info* ~(str *ns*) ~(callsite-coords &form) ~msg nil       nil)))\n     ([msg data-map      ] `(throw (ex-info* ~(str *ns*) ~(callsite-coords &form) ~msg ~data-map nil)))\n     ([msg data-map cause] `(throw (ex-info* ~(str *ns*) ~(callsite-coords &form) ~msg ~data-map ~cause)))))\n\n#?(:clj\n   (defmacro unexpected-arg!\n     \"Throws a `truss/ex-info` to indicate an unexpected argument:\n\n       (defn my-function [mode]\n         (case mode\n           :read  (do <...>)\n           :write (do <...>)\n           (unexpected-arg! mode\n             {:param       'mode\n              :context  `my-function\n              :expected #{:read :write}})))\n\n       (my-function :invalid-mode) => throws\n         Unexpected argument: :invalid-mode\n         {:param 'mode,\n          :arg {:value :unexpected, :type clojure.lang.Keyword},\n          :context 'my-ns/my-function,\n          :expected #{:read :write}\n          ...}\"\n\n     {:arglists '([arg] [arg kvs])}\n     ([arg k1 v1 & more] `(unexpected-arg!* ~(str *ns*) ~(callsite-coords &form) ~arg ~(apply hash-map k1 v1 more))) ; Back compatibility\n     ([arg    ]          `(unexpected-arg!* ~(str *ns*) ~(callsite-coords &form) ~arg nil))\n     ([arg kvs]          `(unexpected-arg!* ~(str *ns*) ~(callsite-coords &form) ~arg ~kvs))))\n\n;;;; Context utils\n\n(defn set-ctx!\n  \"Set `*ctx*` var's default (root) value. See `*ctx*` for details.\"\n  [root-ctx-val]\n  #?(:clj  (alter-var-root (var *ctx*) (fn [_] root-ctx-val))\n     :cljs (set!                *ctx*          root-ctx-val)))\n\n(defmacro with-ctx\n  \"Evaluates given body with given `*ctx*` value. See `*ctx*` for details.\"\n  [ctx-val & body] `(binding [*ctx* ~ctx-val] ~@body))\n\n(defn ^:no-doc update-ctx\n  \"Returns `new-ctx` given `old-ctx` and an update map or fn.\"\n  [old-ctx update-map-or-fn]\n  (cond\n    (nil? update-map-or-fn)           old-ctx\n    (map? update-map-or-fn) (conj (or old-ctx) update-map-or-fn) ; Before ifn\n    (ifn? update-map-or-fn) (update-map-or-fn old-ctx)\n    :else\n    (unexpected-arg! update-map-or-fn\n      {:param       'update-map-or-fn\n       :context  `update-ctx\n       :expected '#{nil map fn}})))\n\n(defmacro with-ctx+\n  \"Evaluates given body with updated `*ctx*` value.\n\n  `update-map-or-fn` may be:\n    - A map to merge with    current `*ctx*` value, or\n    - A unary fn to apply to current `*ctx*` value\n\n  See `*ctx*` for details.\"\n  [update-map-or-fn & body]\n  `(binding [*ctx* (update-ctx *ctx* ~update-map-or-fn)]\n     ~@body))\n\n;;;; Error utils\n\n(defn error?\n  \"Returns true iff given platform error (`Throwable` or `js/Error`).\"\n  #?(:cljs {:tag 'boolean})\n  [x]\n  #?(:clj  (instance? Throwable x)\n     :cljs (instance? js/Error  x)))\n\n(defn ^:no-doc ex-root\n  \"Private, don't use.\n  Returns root cause of given platform error.\"\n  [x]\n  (when (error? x)\n    (loop [error x]\n      (if-let [cause (ex-cause error)]\n        (recur cause)\n        error))))\n\n(comment (ex-root (ex-info \"Ex2\" {:k2 \"v2\"} (ex-info \"Ex1\" {:k1 \"v1\"}))))\n\n(defn ^:no-doc ex-type\n  \"Private, don't use.\n  Returns class symbol of given platform error.\"\n  [x]\n  #?(:clj (symbol (.getName (class x)))\n     :cljs\n     (cond\n       (instance? ExceptionInfo x) `ExceptionInfo ; Note namespaced\n       (instance? js/Error      x) (symbol \"js\" (.-name x)))))\n\n(defn ^:no-doc ex-map*\n  \"Private, don't use.\n  Returns ?{:keys [type msg data]} for given platform error.\"\n  [x]\n  (when-let [msg             (ex-message x)]\n    (if-let [data (not-empty (ex-data    x))]\n      {:type (ex-type x), :msg msg, :data data}\n      {:type (ex-type x), :msg msg})))\n\n(comment (ex-map* (ex-info \"Ex2\" {:k2 \"v2\"} (ex-info \"Ex1\" {:k1 \"v1\"}))))\n\n(defn ^:no-doc ex-chain\n  \"Private, don't use.\n  Returns vector cause chain of given platform error.\"\n  ([         x] (ex-chain false x))\n  ([as-maps? x]\n   (when (error? x)\n     (let [xf (if as-maps? ex-map* identity)]\n       (loop [acc [(xf x)], error x]\n         (if-let [cause (ex-cause error)]\n           (recur (conj acc (xf cause)) cause)\n           (do          acc)))))))\n\n(comment (ex-chain :as-maps (ex-info \"Ex2\" {:k2 \"v2\"} (ex-info \"Ex1\" {:k1 \"v1\"}))))\n\n#?(:clj\n   (defn- st-element->map [^StackTraceElement ste]\n     {:class  (symbol (.getClassName  ste))\n      :method (symbol (.getMethodName ste))\n      :file           (.getFileName   ste)\n      :line           (.getLineNumber ste)}))\n\n;; #?(:clj\n;;    (defn- st-element->str ^String [^StackTraceElement ste]\n;;      (str\n;;        \"`\" (.getClassName ste) \"/\" (.getMethodName ste) \"`\"\n;;        \" at \" (.getFileName ste) \":\" (.getLineNumber ste))))\n\n(defn ^:no-doc ex-map\n  \"Private, don't use.\n  Returns ?{:keys [type msg data chain trace]} for given platform error.\"\n  [x]\n  (when-let [chain (ex-chain x)]\n    (let [maps     (mapv ex-map* chain)\n          root     (peek chain)\n          root-map (peek maps)]\n\n      (impl/assoc-some root-map\n        {:chain maps\n         :trace\n         #?(:cljs (when-let [st (.-stack root)] (when-not (= st \"\") st))\n            :clj\n            (when-let [st (not-empty (.getStackTrace ^Throwable root))] ; Don't delay\n              (delay (mapv st-element->map st))))}))))\n\n(comment\n  (ex-map  (ex-info \"Ex2\" {:k2 \"v2\"} (ex-info \"Ex1\" {:k1 \"v1\"})))\n  (ex-map  (ex-info \"Ex2\" {:k2 \"v2\"} (ex-info \"Ex1\" {:k1 \"v1\"})))\n  (let [ex (ex-info \"Ex2\" {:k2 \"v2\"} (ex-info \"Ex1\" {:k1 \"v1\"}))]\n    (enc/qb 1e5 ; [21.22 114.51]\n      (ex-map         ex)\n      (Throwable->map ex))))\n\n#?(:clj (defn ^:no-doc critical-error?     [x] (and (instance? Error     x) (not (instance? AssertionError x)))))\n#?(:clj (defn-     non-critical-throwable? [x] (and (instance? Throwable x) (not (critical-error? x)))))\n#?(:clj\n   (defn ^:no-doc throw-critical\n     \"Private, don't use.\n     If given any `Error` besides `AssertionError`, (re)throw it.\n     Useful as a hack to allow easily catching both `Exception` and `AssertionError`:\n       (try <body> (catch Throwable t (throw-critical t) <body>)), etc.\"\n     [x] (when (critical-error? x) (throw x))))\n\n#?(:clj\n   (defmacro try*\n     \"Like `try`, but `catch` clause class may be:\n       `:ex-info` -- Catches only `ExceptionInfo`\n       `:common` --- Catches `js/Error` (Cljs), `Exception` (Clj)\n       `:all` ------ Catches `:default` (Cljs), `Throwable` (Clj)\n       `:default` -- Catches `:default` (Cljs), `Exception`, and `AssertionError` (Clj)\n                     but NOT other (usually critical) `Error`s\n\n     Addresses CLJ-1293 and the fact that `AssertionError`s are typically NON-critical\n     (so desirable to catch, in contrast to other `Error` classes).\"\n     {:arglists '([expr* catch-clauses* ?finally-clause])}\n     [& forms]\n     (let [cljs? (some? (:ns &env))\n           forms\n           (mapv\n             (fn [in]\n               (if-not (impl/list-form? in)\n                 in\n                 (let [[s1 s2 s3 & more] in]\n                   (cond\n                     (not= s1 'catch)    in\n                     (not (keyword? s2)) in\n                     :else\n                     (let [[rethrow-critical? s2]\n                           (case s2\n                             (:all     :any)              (if cljs? [false  :default] [false `Throwable])\n                             (:default :all-but-critical) (if cljs? [false  :default] [true  `Throwable])\n                             (:common)                    (if cljs? [false 'js/Error] [false `Exception])\n                             (:ex-info)\n                             (if cljs?\n                               [false    'cljs.core.ExceptionInfo]\n                               [false 'clojure.lang.ExceptionInfo])\n\n                             (throw\n                               (ex-info \"Unexpected Truss `try*` catch clause keyword\"\n                                 {:given    {:value s2, :type (type s2)}\n                                  :expected '#{:ex-info :common :all :default}})))]\n\n                       (if rethrow-critical?\n                         `(catch ~s2 ~s3 (throw-critical ~s3) ~@more)\n                         `(catch ~s2 ~s3                      ~@more)))))))\n             forms)]\n\n       `(try ~@forms))))\n\n(comment\n  (macroexpand '(try*         (catch :all     t t 1 2 3) (finally 1 2 3)))\n  (macroexpand '(try* (/ 1 0) (catch :all     t t 1 2 3) (finally 1 2 3)))\n  (macroexpand '(try* (/ 1 0) (catch :default t t 1 2 3) (finally 1 2 3))))\n\n#?(:clj\n   (defmacro catching\n     \"Terse cross-platform util to swallow exceptions in `expr`.\n     Like (try* expr (catch :default _ nil)). See also `try*`.\"\n     ([            expr] `(try* ~expr (catch :default     ~'_)))\n     ([catch-class expr] `(try* ~expr (catch ~catch-class ~'_)))))\n\n(comment (catching (zero? \"9\")))\n\n(defn matching-error\n  \"Given a platform error and criteria for matching, returns the error if it\n  matches all criteria. Otherwise returns nil.\n\n  `kind` may be:\n    - A class (`ArithmeticException`, `AssertionError`, etc.)\n    - A special keyword as given to `try*` (`:default`, `:common`, `:ex-info`, `:all`)\n    - A set of `kind`s  as above, at least one of which must match\n    - A predicate function, (fn match? [x]) -> bool\n\n  `pattern` may be:\n    - A string or Regex against which `ex-message` must match\n    - A map             against which `ex-data`    must match using `submap?`\n    - A set of `pattern`s as above, at least one of which must match\n\n  When an error with (nested) causes doesn't match, a match will be attempted\n  against its (nested) causes.\n\n  This is a low-level util, see also `throws`, `throws?`.\"\n  ([     error] error)\n  ([kind error]\n   (when-let [match?\n              (cond\n                (keyword? kind)\n                (case     kind\n                  (:default :all-but-critical) #?(:clj (non-critical-throwable?               error) :cljs (some?                   error))\n                  (:common)                    #?(:clj (instance? Exception                   error) :cljs (instance? js/Error      error))\n                  (:ex-info)                   #?(:clj (instance? clojure.lang.IExceptionInfo error) :cljs (instance? ExceptionInfo error))\n                  (:all :any)                  #?(:clj (instance? Throwable                   error) :cljs (some?                   error))\n                  (throw\n                    (ex-info \"Unexpected Truss `matching-error` `kind` keyword\"\n                      {:given    (typed-val kind)\n                       :expected '#{:default :common :ex-info :all}})))\n\n                (error? kind) (= kind error) ; Exact match\n                (fn?    kind) (kind error)   ; Pred\n                (set?   kind) (impl/rsome #(matching-error % error) kind)\n                :else (instance? kind error))]\n     error))\n\n  ([kind pattern error]\n   (if-let [match?\n            (and\n              (matching-error kind error)\n              (cond\n                (nil?             pattern) true\n                (set?             pattern) (impl/rsome #(matching-error kind % error) pattern)\n                (string?          pattern) (impl/str-contains?     (ex-message error) pattern)\n                (impl/re-pattern? pattern) (re-find pattern        (ex-message error))\n                (map?             pattern) (when-let [data         (ex-data    error)]\n                                             (submap? data pattern))\n                :else\n                (unexpected-arg! pattern\n                  {:param       'pattern\n                   :context  `matching-error\n                   :expected '#{nil set string re-pattern map}})))]\n     error\n     ;; Try match cause\n     (when-let [cause (ex-cause error)]\n       (matching-error kind pattern cause)))))\n\n#?(:clj\n   (defmacro throws\n     \"Evals `form` and if it throws an error that matches given criteria using\n     `matching-error`, returns the matching error. Otherwise returns nil.\n\n     Useful for unit tests, e.g.:\n       (is (throws :default {:a :b}  (throw (ex-info \\\"MyEx\\\" {:a :b, :c :d})))) ; => ExceptionInfo\n       (is (throws :default \\\"MyEx\\\" (throw (ex-info \\\"MyEx\\\" {:a :b, :c :d})))) ; => ExceptionInfo\n\n     See also `throws?`, `matching-error`.\"\n     ([             form] `                               (try* ~form nil (catch :all ~'t ~'t)))\n     ([kind         form] `(matching-error ~kind          (try* ~form nil (catch :all ~'t ~'t))))\n     ([kind pattern form] `(matching-error ~kind ~pattern (try* ~form nil (catch :all ~'t ~'t))))))\n\n#?(:clj\n   (defmacro throws?\n     \"Evals `form` and if it throws an error that matches given criteria using\n     `matching-error`, returns true. Otherwise returns false.\n\n     Useful for unit tests, e.g.:\n       (is (throws? :default {:a :b}  (throw (ex-info \\\"MyEx\\\" {:a :b, :c :d})))) ; => true\n       (is (throws? :default \\\"MyEx\\\" (throw (ex-info \\\"MyEx\\\" {:a :b, :c :d})))) ; => true\n\n     See also `throws`, `matching-error`.\"\n     ([             form] `(boolean (throws                ~form)))\n     ([kind         form] `(boolean (throws ~kind          ~form)))\n     ([kind pattern form] `(boolean (throws ~kind ~pattern ~form)))))\n\n(let [get-default-error-fn\n      (fn [base-data]\n        (let [msg       (get    base-data :error/msg \"Error thrown during reduction\")\n              base-data (dissoc base-data :error/msg)]\n\n          (fn default-error-fn [data cause] ; == (partial ex-info <msg>)\n            (throw (ex-info msg (conj base-data data) cause)))))]\n\n  (defn catching-rf\n    \"Returns wrapper around given reducing function `rf` so that if `rf`\n    throws, (error-fn <thrown-error> <contextual-data>) will be called.\n\n    The default `error-fn` will rethrow the original error, wrapped in\n    extra contextual information to aid debugging.\n\n    Helps make reducing fns easier to debug!\n    See also `catching-xform`.\"\n    ([         rf] (catching-rf (get-default-error-fn {:rf rf}) rf))\n    ([error-fn rf]\n     (let [error-fn\n           (if (map? error-fn) ; Undocumented convenience\n             (get-default-error-fn error-fn)\n             (do                   error-fn))]\n\n       (fn catching-rf\n         ([       ] (try* (rf)        (catch :all t (error-fn {:rf rf :call '(rf)} t))))\n         ([acc    ] (try* (rf acc)    (catch :all t (error-fn {:rf rf :call '(rf acc)    :args {:acc (typed-val acc)}} t))))\n         ([acc in ] (try* (rf acc in) (catch :all t (error-fn {:rf rf :call '(rf acc in) :args {:acc (typed-val acc)\n                                                                                                :in  (typed-val in)}} t))))\n         ([acc k v]\n          (try* (rf acc k v)\n            (catch :all t\n              (error-fn\n                {:rf     rf\n                 :call '(rf acc k v)\n                 :args\n                 {:acc (typed-val acc)\n                  :k   (typed-val k)\n                  :v   (typed-val v)}}\n                t)))))))))\n\n(defn catching-xform\n  \"Like `catching-rf`, but applies to a transducer (`xform`).\n\n  Helps make transductions much easier to debug by greatly improving\n  the info provided in any errors thrown by `xform` or the reducing fn:\n\n    (transduce\n      (catching-xform (comp (filter even?) (map inc))) ; Modified xform\n      <reducing-fn>\n      <...>)\"\n\n  ([error-fn xform] (comp (fn [rf] (catching-rf error-fn rf)) xform))\n  ([         xform] (comp           catching-rf               xform)))\n\n;;;; Assertions\n\n(def ^:private sys-newline #?(:cljs \"\\n\" :clj (System/getProperty \"line.separator\")))\n\n(let [legacy-ex-data? (impl/legacy-assertion-ex-data?)]\n\n  (defn failed-assertion-ex-info\n    \"Returns an appropriate `truss/ex-info` for given failed assertion info map.\"\n    ([                failed-assertion-info] (failed-assertion-ex-info legacy-ex-data? failed-assertion-info))\n    ([legacy-ex-data? failed-assertion-info]\n     (let [{:keys [inst ns coords, pred arg-form arg-val, data error]} failed-assertion-info\n           undefined-arg? (impl/identical-kw? arg-val :truss/exception)\n\n           coords-str ; Faster (str coords)\n           (when-let [[line column] coords]\n             (if column\n               (str \"[\" line \",\" column \"]\")\n               (str \"[\" line \"]\")))\n\n           msg (str \"Truss assertion failed at \" ns coords-str \": \" (list pred arg-form))\n           msg\n           (if error\n             (let [error-msg (ex-message error)]\n               (if undefined-arg?\n                 (str msg sys-newline \"Error evaluating arg: \"  error-msg)\n                 (str msg sys-newline \"Error evaluating pred: \" error-msg)))\n             msg)]\n\n       (ex-info msg\n\n         (if legacy-ex-data?\n           {:dt     (impl/now-dt*)\n            :loc    (let [[line column] coords] {:ns ns, :line line, :column column})\n            :msg    msg\n            :pred   pred\n            :data   {:arg data, :dynamic *ctx*}\n            :env    {:*assert* *assert*}\n            :error  error\n            :arg\n            {:form  arg-form\n             :value arg-val\n             :type  (if undefined-arg? :truss/exception (type arg-val))}}\n\n           (impl/assoc-some\n             {:inst   (impl/now-inst*)\n              :ns     ns\n              :pred   pred\n              :arg\n              {:form  arg-form\n               :value arg-val\n               :type  (if undefined-arg? :truss/exception (type arg-val))}}\n             {:coords coords\n              :data   data}))\n\n         error)))))\n\n(def ^:dynamic *failed-assertion-handler*\n  \"Unary handler fn to call with failed assertion info map when a Truss\n  assertion (`have`, `have?`, `have!`, `have!?`) fails.\n\n  Will by default throw an appropriate `truss/ex-info`.\n  This is a decent place to inject logging for assertion failures, etc.\n\n  Arg given to handler is a map with keys:\n\n  `:ns` ----------- ?str namespace of assertion callsite\n  `:coords` ------- ?[line column] of assertion callsite\n\n  `:pred` --------- Assertion predicate form  (e.g. `clojure.core/string?` sym)\n  `:arg-form` ----- Assertion argument  form given  to predicate (e.g. `x` sym)\n  `:arg-val` ------ Runtime value of argument given to predicate\n\n  `:data` --------- Optional arbitrary data map provided to assertion macro\n  `:error` -------- `Throwable` or `js/Error` thrown evaluating predicate\"\n\n  (fn  [failed-assertion-info]\n    (-> failed-assertion-info failed-assertion-ex-info throw)))\n\n(comment\n  (let [foo (fn [x] (have true? x))]\n    (binding [*failed-assertion-handler* identity] (foo false))))\n\n(defn ^:no-doc failed-assertion!\n  \"Private, don't use.\"\n  [ns line column, pred arg-form arg-val, data-fn error]\n  (if-let [;; Not accessible from impl ns in Cljs\n           handler *failed-assertion-handler*]\n    (handler\n      (let [undefined-arg? (instance? ArgEvalError arg-val)]\n        (FailedAssertionInfo. ns\n          (when line (if column [line column] [line]))\n          pred arg-form\n          (if undefined-arg? :truss/exception arg-val)\n          (when-let [df data-fn] (impl/catching (df) _ :truss/exception))\n          (cond\n            (identical? error impl/FalsePredError) nil\n            undefined-arg? (.-ex ^ArgEvalError error)\n            :else                              error))))\n    arg-val))\n\n#?(:clj\n   (defmacro have\n     \"Main Truss assertion util.\n     Takes a (fn pred [x]) => truthy, and >=1 vals.\n     Tests pred against each val,trapping errors.\n\n     If any pred test fails, throws a detailed `truss/ex-info`.\n     Otherwise returns input val/s for convenient inline-use/binding.\n\n     Respects `*assert*`, so tests can be elided from production if desired\n     (meaning zero runtime cost).\n\n     Examples:\n       (defn my-trim [x] (str/trim (have string? x)))\n\n       ;; Add arb optional info to thrown ex-data using `:data`:\n       (have string? \\\"foo\\\" :data {:user-id 101}) => \\\"foo\\\"\n\n       ;; Assert inside collections using `:in`:\n       (have string? :in #{\\\"foo\\\" \\\"bar\\\"}) => #{\\\"foo\\\" \\\"bar\\\"}\n\n     Regarding use within other macros:\n       Due to CLJ-865, callsite info like line number of outer macro\n       will be lost. See `keep-callsite` for workaround.\n\n     See also `have?`, `have!`.\"\n     {:arglists '([x] [pred (:in) x] [pred (:in) x & more-xs])}\n     [& args] `(impl/assert-args true false ~(callsite-coords &form) ~args)))\n\n#?(:clj\n   (defmacro have?\n     \"Truss assertion util.\n     Like `have` but returns `true` (rather than given arg value) on success.\n     Handy for `:pre`/`:post` conditions. Compare:\n       ((fn my-fn [] {:post [(have  nil? %)]} nil)) ; {:post [nil ]} FAILS\n       ((fn my-fn [] {:post [(have? nil? %)]} nil)) ; {:post [true]} passes as intended\"\n     {:arglists '([x] [pred (:in) x] [pred (:in) x & more-xs])}\n     [& args] `(impl/assert-args true true ~(callsite-coords &form) ~args)))\n\n#?(:clj\n   (defmacro have!\n     \"Truss assertion util.\n     Like `have` but ignores `*assert*` value (so will never be elided).\n     Useful for important conditions in production (e.g. security checks).\"\n     {:arglists '([x] [pred (:in) x] [pred (:in) x & more-xs])}\n     [& args] `(impl/assert-args false false ~(callsite-coords &form) ~args)))\n\n#?(:clj\n   (defmacro have!?\n     \"Truss assertion util.\n     Returns `true` (rather than given arg value) on success, and ignores\n     `*assert*` value (so will never be elided).\n  \n     **WARNING**: do NOT use in `:pre`/`:post` conditions since those ALWAYS\n     respect `*assert*`, contradicting the intention of the bang (`!`) here.\"\n     {:arglists '([x] [pred (:in) x] [pred (:in) x & more-xs])}\n     [& args] `(impl/assert-args false true ~(callsite-coords &form) ~args)))\n\n;;;; Deprecated\n\n(defn ^:no-doc legacy-error-fn\n  \"Private, don't use. Wraps given Truss v1 `error-fn` to convert\n  Truss v2 `*failed-assertion-handler*` arg.\"\n  [f]\n  (when f\n    (fn [failed-assertion-info]\n      (f\n        (delay\n          (let [{:keys [ns coords, pred arg-form arg-val, data error]} failed-assertion-info\n                [line column] coords\n                msg_\n                (delay\n                  (let [msg\n                        (str \"Invariant failed at \" ns\n                          (when line (str \"[\" line (when column (str \",\" column)) \"]\")) \": \"\n                          (list pred arg-form))]\n\n                    (if error\n                      (let [error-msg (ex-message error)]\n                        (if (impl/identical-kw? arg-val :truss/exception)\n                          (str msg sys-newline sys-newline \"Error evaluating arg: \"  error-msg)\n                          (str msg sys-newline sys-newline \"Error evaluating pred: \" error-msg)))\n                      msg)))]\n\n            (impl/assoc-some\n              {:msg_ msg_\n               :dt   #?(:clj (java.util.Date.) :cljs (js/Date.))\n               :pred pred\n               :arg  {:form        arg-form\n                      :value       arg-val\n                      :type  (type arg-val)}\n               :env  {:*assert* *assert*}\n               :loc  {:ns ns, :line line, :column column}}\n\n              {:data (impl/assoc-some nil {:dynamic *ctx* :arg data})\n               :err  error})))))))\n\n(defn ^:no-doc ^:deprecated get-dynamic-assertion-data \"Prefer `*ctx*`\" [] *ctx*)\n(defn ^:no-doc ^:deprecated get-data                   \"Prefer `*ctx*`\" [] *ctx*)\n(defn ^:no-doc ^:deprecated set-error-fn!\n  \"Prefer `*failed-assertion-handler*` (note breaking changes to argument).\"\n  [f]\n  #?(:cljs (set!             *failed-assertion-handler*         (legacy-error-fn f))\n     :clj  (alter-var-root #'*failed-assertion-handler* (fn [_] (legacy-error-fn f)))))\n\n#?(:clj (defmacro ^:no-doc ^:deprecated with-dynamic-assertion-data \"Prefer `*ctx*`\" [data & body] `(binding [*ctx* ~data] ~@body)))\n#?(:clj (defmacro ^:no-doc ^:deprecated with-data                   \"Prefer `*ctx*`\" [data & body] `(binding [*ctx* ~data] ~@body)))\n#?(:clj\n   (defmacro ^:no-doc ^:deprecated with-error-fn\n     \"Prefer `*failed-assertion-handler*` (note breaking changes to argument).\"\n     [f & body]\n     `(binding [*failed-assertion-handler* (legacy-error-fn ~f)]\n        ~@body)))\n\n(comment (force (:msg_ (with-data {:a :A} (with-error-fn force (have true? false))))))\n","~:reader-features",["^[",["~:cljs"]],"~:used-var-namespaces",["^[",["^H","^27","~$js","^29"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings",";AAuBA,AAoCA;;;;;;;;;;;;+BAAA,/BAAeA,sEAWZC,UAAUC;AAXb,AAYE,OAACC,oBACC,WAAKC,EAAEC,QAAQC;AAAf,AACE,GAAI,AAACC,qBAAQD;AACX,IAAME,YAAU,AAACC,4CAAIR,UAAUI;AAA/B,AACE,IAAAK,qBAAgB,iBAAAE,oBAAK,AAACL,qBAAKC;AAAX,AAAA,GAAAI;AAAsB,QAACZ,6DAAAA,gFAAAA,rBAAQQ,4DAAAA,lDAAUF,4DAAAA;;AAAzCM;;;AAAhB,AAAA,oBAAAF;AAAA,mBAAAA,fAASC;AAAT,AAAA;;AAEE,yBAAA,lBAACE;;;AAEL,IAAML,YAAU,8DAAA,9DAACC,4CAAIR,UAAUI;AAA/B,AACE,IAAAK,qBACS,iBAAAA,qBAAiB,gCAAA,QAAA,tCAAM,AAACK,oBAAIT,UAASA;AAArC,AAAA,oBAAAI;AAAA,cAAAA,VAASI;AAAT,AACE,QAACA,wCAAAA,mDAAAA,bAAQN,+BAAAA;;AACT,IAAAQ,WAAMV;IAANU,eAAA,EAAA,CAAAA,oBAAAC,oBAAA,AAAAD,aAAA;AAAA,AAAA,QAAAA;KAAA;AACkB,OAAAE,6CAAA,VAAoBV;;;KADtC;AAEa,UAAK,AAAAU,6CAAA,VAAoBV;;;KAFtC;AAG+B,UAAA,cAAA,bAAOA;;;;AACpC,OAACW,6CAAEb,QAAQE;;;;;AAPxB,AAAA,oBAAAE;AAAA,mBAAAA,fAASC;AAAT,AAAA;;AASE,yBAAA,lBAACE;;;GAlBX,KAoBEX;;AAIJ;;;;;;;;;iCAAA,jCAAekB;AAUf;;;+BAAA,/BAAeC,sEAEZC,GAAGC,OAAOC,IAAIC,SAASC;AAF1B,AAGE,IAAMD,eACA,kBAAIF,QACF,6CAAA,2CAAA,mDAAA,3IAACI,wIAAUL,4DAAYC,eAAQE,UAC/B,6CAAA,2CAAA,xFAACE,wIAAUL,WAAoBG;IAEjCA,eACA,iBAAAf,qBAAaU;AAAb,AAAA,oBAAAV;AAAA,UAAAA,NAASkB;AAAT,AACE,kEAAA,3DAACC,8CAAMJ,yEAAoBG;;AAC3B,AAAOH;;;AARf,AAUE,OAACK,gDAAaN,IAAIC,aAASC;;AAE/B;;;4CAAA,5CAAeK,gGAEZT,GAAGC,OAAOS,IAAIC;AAFjB,AAGE,MACE,AAACZ,6BAASC,GAAGC,OACX,iBAAAW,mBAAO,gDAAA,hDAACzB,4CAAOwB;AAAf,AAAA,oBAAAC;AAAAA;;AAAyB,WAAA,oEAA6B,iBAAA,fAAI,QAAA,PAAMF,sBAAaA;;sYAD/E,jYAEE,sJAAA,tJAACH,8CAAM,mDAAA,nDAACM,+CAAOF,6GAAe,2CAAA,0DAAA,qDAAA,AAAAG,zDAAWJ,wEAAAA;;AAiD/C;;;+BAAA,/BAAMK,sEAEHC;AAFH,AAIW,QAAqBlB,iCAAekB;;AAM/C;;;4BAAA,5BAAeC,gEAEZC,QAAQC;AAFX,AAGE,GACE,qBAAA,pBAAMA;AAA4BD;;AADpC,GAEE,AAACjC,qBAAKkC;AAAkB,OAACd,6CAASa,QAASC;;AAF7C,GAGE,AAACC,qBAAKD;AAAkB,QAACA,iDAAAA,0DAAAA,XAAiBD,sCAAAA;;AAH5C,AAKE,OAAAT,0CAAA,iBAAA,mFAAA,IAAA,2BAAA,2CAAA,uDAAA,AAAA,iFAAA,2DAAA,AAAA,gGAAA,6DAAA,AAAA,5ZAAiBU;;;;;;AAmBrB;;;8BAAA,9BAAME,oEAGHC;AAHH,AAKW,qBAAWC,bAAUD;;AAEhC;;;;yBAAA,zBAAeE,0DAGZF;AAHH,AAIE,oBAAM,AAACD,4BAAOC;AAAd,AACE,IAAOG,QAAMH;;AAAb,AACE,IAAAlC,qBAAe,AAACsC,mBAASD;AAAzB,AAAA,oBAAArC;AAAA,YAAAA,RAASgB;AAAT,AACE,eAAOA;;;;AACPqB;;;;;AAJN;;;AAMF,AAEA;;;;yBAAA,zBAAeE,0DAGZL;AAHH,AAMK,GACE,cAAWM,bAAcN;AAD3B,AAAA;;AAAA,GAEE,cAAWC,bAAcD;AAAG,sDAAA,/CAACO,oDAAY,AAAQP;;AAFnD;;;;AAIL;;;;8BAAA,9BAAeQ,oEAGZR;AAHH,AAIE,IAAAS,qBAA2B,AAACC,qBAAWV;AAAvC,AAAA,oBAAAS;AAAA,AAAA,UAAAA,NAAW7B;AAAX,AACE,IAAAd,qBAAc,AAAC8C,oBAAU,AAACC,kBAAWb;AAArC,AAAA,oBAAAlC;AAAA,WAAAA,PAAS6C;AAAT,AAAA,kDAAA,+EAAA,wDAAA,lFACS,AAACN,uBAAQL,uDAASpB,yDAAW+B;;AADtC,kDAAA,+EAAA,1BAES,AAACN,uBAAQL,uDAASpB;;;AAH7B;;;AAKF,AAEA,AAAA;;;;0BAAA,kCAAAkC,5DAAeE;AAAf,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,sDAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,sDAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAf,MAAA,AAAA,CAAA,kBAAA,AAAA,uBAAA;;;;;AAAA,CAAA,wDAAA,xDAAee,mEAGFhB;AAHb,AAGgB,6DAAA,tDAACiB,4DAAejB;;;AAHhC,CAAA,wDAAA,xDAAegB,mEAIXE,eAASlB;AAJb,AAKG,oBAAM,AAACD,4BAAOC;AAAd,AACE,IAAMmB,KAAG,kBAAID,gBAASV,4BAAQY;AAA9B,AACE,UAAA,NAAOC,yFAAK,CAACF,mCAAAA,sCAAAA,LAAGnB,kBAAAA;IAAKG,QAAMH;;AAA3B,AACE,IAAAlC,qBAAe,AAACsC,mBAASD;AAAzB,AAAA,oBAAArC;AAAA,YAAAA,RAASgB;AAAT,AACE,eAAO,AAACC,6CAAKsC,IAAI,CAACF,mCAAAA,0CAAAA,TAAGrC,sBAAAA;eAAQA;;;;;AAC7B,AAAauC;;;;;AALrB;;;;AALH,CAAA,kDAAA,lDAAeL;;AAAf,AAYA,AAeA;;;;wBAAA,xBAAeM,wDAGZtB;AAHH,AAIE,IAAAS,qBAAiB,AAACQ,sDAASjB;AAA3B,AAAA,oBAAAS;AAAA,AAAA,YAAAA,RAAWc;AAAX,AACE,IAAMC,OAAS,AAACC,6CAAKjB,4BAAQe;IACvBG,OAAS,AAACC,eAAKJ;IACfK,WAAS,AAACD,eAAKH;AAFrB,AAIE,6EAAA,2CAAA,0DAAA,3KAACK,6DAAgBD,yGACPJ,6DAEE,iBAAAf,yBAAc,AAASiB;AAAvB,AAAA,oBAAAjB;AAAA,AAAA,SAAAA,LAAWqB;AAAX,AAA8B,GAAU,gDAAA,hDAACvD,6CAAEuD;AAAb;;AAAA,AAAoBA;;;AAAlD;;;;AARhB;;;AAaF,AAgEA,AAYA,AAEA,AAAA;;;;;;;;;;;;;;;;;;;;gCAAA,wCAAAhB,xEAAMkB;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,4DAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,4DAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,4DAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAA/B,MAAA,AAAA,CAAA,kBAAA,AAAA,uBAAA;;;;;AAAA,CAAA,8DAAA,9DAAM+B,yEAmBG7B;AAnBT,AAmBgBA;;;AAnBhB,CAAA,8DAAA,9DAAM6B,yEAoBFC,KAAK9B;AApBT,AAqBG,IAAAM,qBACW,EACE,iBAAApC,hBAAU4D,oCACV,iBAAAC,WAAUD;IAAVC,eAAA,EAAA,CAAAA,oBAAA7D,oBAAA,AAAA6D,aAAA;AAAA,AAAA,QAAAA;KAAA;KAAA;AAC2F,UAAA,UAAA,TAAyB/B;;;KADpH;AAE2F,yBAAWF,jBAAcE;;;KAFpH;AAG2F,yBAAWG,jBAAcH;;;KAHpH;KAAA;AAI2F,UAAA,UAAA,TAAyBA;;;;AAClH,MACE,AAAA1B,6BAAA,iBAAA,mFAAA,IAAA,WAAA,mDAAA,2CAAA,8OAAA,6DAAA,AAAA,uWAAA,5lBACa,2CAAA,2DAAA,qDAAA,AAAAe,1DAAWyC,yEAAAA;;;KAT9B,8GAAA,sIAAA,lOAYE,AAAClC,4BAAOkC,OAAM,AAAC1D,6CAAE0D,KAAK9B,SACtB,AAAChC,oBAAO8D,OAAM,CAACA,qCAAAA,4CAAAA,TAAK9B,wBAAAA,UACpB,AAACgC,qBAAOF,OAAM,0BAAA,WAAAG,rCAACC;AAAD,AAAa,mEAAAD,5DAACE,6EAAiBnC;SAd/C,NAcsD8B,MAC9C,kBAAWA,jBAAK9B;;AAhBnC,AAAA,oBAAAM;AAAA,AAAA,mBAAAA,fAAW1C;AAAX,AAiBEoC;;AAjBF;;;;AArBH,CAAA,8DAAA,9DAAM6B,yEAwCFC,KAAKM,QAAQpC;AAxCjB,AAyCG,IAAArC,qBACS,iBAAAE,oBACE,AAACsE,4DAAeL,KAAK9B;AADvB,AAAA,oBAAAnC;AAEE,GACE,YAAA,XAAkBuE;AADpB;;AAAA,GAEE,AAACJ,qBAAiBI;AAAS,iCAAA,WAAAC,rCAACH;AAAD,AAAa,wEAAAG,jEAACF,4DAAeL,sBAAO9B;GAAOoC;;AAFxE,GAGE,OAAkBA;AAAS,OAACE,wCAAuB,AAAC/B,qBAAWP,OAAOoC;;AAHxE,GAIE,AAACG,sCAAiBH;AAAS,OAACI,kBAAQJ,QAAe,AAAC7B,qBAAWP;;AAJjE,GAKE,AAACxC,qBAAiB4E;AAAS,IAAA9B,qBAAwB,AAACI,kBAAWV;AAApC,AAAA,oBAAAM;AAAA,AAAA,WAAAA,PAAWE;AAAX,AACE,OAACvD,6BAAQuD,KAAK4B;;AADhB;;;AAL7B,AAQE,OAAApD,0CAAA,iBAAA,mFAAA,IAAA,mBAAA,2CAAA,uDAAA,AAAA,+DAAA,2DAAA,AAAA,uGAAA,6DAAA,AAAA,xYAAiBoD;;;;;;;;AAVrBvE;;;AADT,AAAA,oBAAAF;AAAA,mBAAAA,fAASC;AAAT,AAeEoC;;AAEA,IAAAM,qBAAiB,AAACL,mBAASD;AAA3B,AAAA,oBAAAM;AAAA,AAAA,YAAAA,RAAW3B;AAAX,AACE,OAACwD,4DAAeL,KAAKM,QAAQzD;;AAD/B;;;;;AA1DL,CAAA,wDAAA,xDAAMkD;;AAAN,AAyFA,IAAMY,6BACA,WAAKC;AAAL,AACE,IAAMjE,MAAU,sDAAA,6DAAA,nHAACf,4CAAOgF;IAClBA,gBAAU,yDAAA,zDAACtD,+CAAOsD;AADxB,AAGE,iDAAsBlC,KAAK7B;AAA3B,AACE,MAAO,AAAAL,6BAAA,iBAAA,mFAAA,IAAA,WAASG,IAAI,AAACG,6CAAK8D,cAAUlC,MAAM7B;;;AANtD,AAQE,AAAA;;;;;;;;;;6BAAA,qCAAAgC,lEAAMiC;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,yDAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,yDAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAA9C,MAAA,AAAA,CAAA,kBAAA,AAAA,uBAAA;;;;;AAAA,CAAA,2DAAA,3DAAM8C,sEASOC;AATb,AASiB,OAACC,yDAAY,2BAAA,2CAAA,tEAACL,uHAA0BI,YAAKA;;;AAT9D,CAAA,2DAAA,3DAAMD,sEAUFG,SAASF;AAVb,AAWG,IAAME,eACA,EAAI,AAACvF,qBAAKuF,WACR,AAACN,2BAAqBM,UACtB,AAAsBA;AAH9B,AAKE;;;AAAA,AACa,IAAA,AAAM,QAACF,mCAAAA,qCAAAA;gBAAP,QAAAG,JAA8BC;AAA9B,AAAgC,IAAAC,WAAA,2CAAA,oDAAA,qDAAA,AAAA,xDAAeL;IAAfM,WAA+BF;AAA/B,AAAA,gGAAAC,SAAAC,mCAAAD,SAAAC,7IAACJ,6CAAAA,gEAAAA;;+CAC1C7B;AAFJ,AAEa,IAAA,AAAM,QAAC2B,mCAAAA,wCAAAA,PAAG3B,oBAAAA;gBAAV,QAAAkC,JAA8BH;AAA9B,AAAgC,IAAAI,WAAA,2CAAA,oDAAA,qDAAA,AAAA,6HAAA,qDAAA,2CAAA,rRAAeR,uUAAkC,2CAAA,0DAAA,qDAAA,AAAAxD,zDAAW6B,wEAAAA;IAA5DoC,WAAmEL;AAAnE,AAAA,gGAAAI,SAAAC,mCAAAD,SAAAC,7IAACP,6CAAAA,gEAAAA;;+CAC1C7B,IAAIqC;AAHR,AAGa,IAAA,AAAM,QAACV,mCAAAA,4CAAAA,XAAG3B,wBAAAA,pBAAIqC,wBAAAA;gBAAd,QAAAC,JAA8BP;AAA9B,AAAgC,IAAAQ,WAAA,2CAAA,oDAAA,qDAAA,AAAA,iLAAA,qDAAA,2CAAA,wOAAA,jjBAAeZ,2XAAkC,2CAAA,0DAAA,qDAAA,AAAAxD,zDAAW6B,wEAAAA,+DACX,2CAAA,0DAAA,qDAAA,AAAA7B,zDAAWkE,wEAAAA;IAD5DG,WACkET;AADlE,AAAA,gGAAAQ,SAAAC,mCAAAD,SAAAC,7IAACX,6CAAAA,gEAAAA;;+CAE1C7B,IAAIyC,EAAEC;AALV,AAMG,IAAA,AAAM,QAACf,mCAAAA,4CAAAA,XAAG3B,wBAAAA,pBAAIyC,wBAAAA,tBAAEC,wBAAAA;gBAAhB,QAAAC,JACcZ;AADd,AAEI,IAAAa,WAAA,2CAAA,oDAAA,qDAAA,AAAA,mOAAA,qDAAA,2CAAA,wOAAA,kOAAA,r0BACWjB,6aAGF,2CAAA,0DAAA,qDAAA,AAAAxD,zDAAW6B,wEAAAA,6DACX,2CAAA,wDAAA,qDAAA,AAAA7B,vDAAWsE,sEAAAA,wDACX,2CAAA,wDAAA,qDAAA,AAAAtE,vDAAWuE,sEAAAA;IANpBG,WAOEd;AAPF,AAAA,gGAAAa,SAAAC,mCAAAD,SAAAC,7IAAChB,6CAAAA,gEAAAA;;sCAHJ7B,IAAIyC,EAAEC;;;;;+CAAN1C;;+CAAAA,IAAIyC;;+CAAJzC,IAAIyC,EAAEC;;;;;;;;;;;;AArBf,CAAA,qDAAA,rDAAMhB;;AAAN,AAiCF,AAAA;;;;;;;;;;;gCAAA,wCAAAjC,xEAAMsD;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,4DAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,4DAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAnE,MAAA,AAAA,CAAA,kBAAA,AAAA,uBAAA;;;;;AAAA,CAAA,8DAAA,9DAAMmE,yEAWFlB,SAASmB;AAXb,AAWoB,OAACC,6CAAK,WAAKtB;AAAL,AAAS,OAACC,yDAAYC,SAASF;GAAKqB;;;AAX9D,CAAA,8DAAA,9DAAMD,yEAYOC;AAZb,AAYoB,OAACC,6CAAevB,2BAA0BsB;;;AAZ9D,CAAA,wDAAA,xDAAMD;;AAAN,AAgBA,6BAAA,7BAAeG;AAEf,IAAMC,8BAAgB;AAAtB,AAEE,AAAA;;;0CAAA,kDAAA1D,5FAAM4D;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,sEAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,sEAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAzE,MAAA,AAAA,CAAA,kBAAA,AAAA,uBAAA;;;;;AAAA,CAAA,wEAAA,xEAAMyE,mFAEcC;AAFpB,AAE2C,OAACC,sEAAyBJ,4BAAgBG;;;AAFrF,CAAA,wEAAA,xEAAMD,mFAGFF,0BAAgBG;AAHpB,AAIG,IAAAE,aAAkEF;IAAlEE,iBAAA,AAAAC,4BAAAD;WAAA,AAAAhH,4CAAAgH,eAAA,lEAAcE;SAAd,AAAAlH,4CAAAgH,eAAA,hEAAmBnG;aAAnB,AAAAb,4CAAAgH,eAAA,pEAAsBlG;WAAtB,AAAAd,4CAAAgH,eAAA,lEAA8BG;eAA9B,AAAAnH,4CAAAgH,eAAA,tEAAmCI;cAAnC,AAAApH,4CAAAgH,eAAA,rEAA4CK;WAA5C,AAAArH,4CAAAgH,eAAA,lEAAqDlE;YAArD,AAAA9C,4CAAAgH,eAAA,nEAA0D1E;IACpDgF,uBAAe,AAAA7G,2CAAA,RAAoB4G;IAEnCE,aACA,iBAAA3E,qBAAyB9B;AAAzB,AAAA,oBAAA8B;AAAA,AAAA,IAAA4E,aAAA5E;WAAA,AAAA6E,4CAAAD,WAAA,IAAA,lEAAYE;aAAZ,AAAAD,4CAAAD,WAAA,IAAA,pEAAiBG;AAAjB,AACE,oBAAIA;AACF,WAAA,sDAAA,wDAAA,9DAASD,sDAASC;;AAClB,WAAA,sDAAA,NAASD;;;AAHb;;;IAKA3G,MAAI,IAAA,qIAAA,5DAAkCF,gDAAG0G,6DAAgB,KAAAK,eAAA,UAAA,KAAAA,eAAA,cAAA,KAAA,IAAA,OAAA,IAAA,3DAAMT,8BAAKC;IACpErG,UACA,kBAAIuB,OACF,iBAAMuF,YAAU,AAAChF,qBAAWP;AAA5B,AACE,GAAIgF;AACF,oIAAA,7EAAKvG,iDAAI2F,iGAAsCmB;;AAC/C,oIAAA,7EAAK9G,iDAAI2F,kGAAsCmB;;KACnD9G;AAhBR,AAkBE,OAAAH,6BAAA,iBAAA,mFAAA,IAAA,UAASG,QAEP,6CAAA,2CAAA,8DAAA,pIAAI4F,uHACO,KAAAmB,2DACA,iBAAAC,aAAoBjH;WAApB,AAAA2G,4CAAAM,WAAA,IAAA,lEAAOL;aAAP,AAAAD,4CAAAM,WAAA,IAAA,pEAAYJ;AAAZ,AAAA,kDAAA,mDAAA,yDAAA,5DAAiC9G,uDAAU6G,8DAAcC;KAFpE,4DAAA,0DAAA,qDAAA,2CAAA,yDAAA,iGAAA,oDAAA,2CAAA,kGAAA,6DAAA,oDAAA,2CAAA,+DAAA,8DAAA,txBAGW5G,6DACAoG,yJACMrE,+DAAenC,mMACVqH,4FACX1F,2JAEA8E,+DACAC,6DACA,wBAAA,tBAAIC,8FAAgC,AAAC3F,eAAK0F,0BAEnD,6DAAA,2CAAA,iEAAA,mDAAA,0DAAA,oDAAA,2CAAA,+DAAA,8DAAA,8LAAA,2CAAA,gEAAA,3xBAACrD,4JACU,KAAA8D,wDACAjH,wDACAsG,0JAEAC,+DACAC,6DACA,wBAAA,tBAAIC,8FAAgC,AAAC3F,eAAK0F,8HAC1CvG,4DACAgC,eAEbR;;;AAhDP,CAAA,kEAAA,lEAAMuE;;AAAN,AAkDF;;;;;;;;;;;;;;;;;;;AAAeoB,sDAmBb,8DAAMnB;AAAN,AACE,MAAA,sEAAIA,tEAAsBC;;AAE9B,AAIA;;;wCAAA,xCAAemB,wFAEZrH,GAAG6G,KAAKC,OAAQR,KAAKC,SAASC,QAASc,QAAQ7F;AAFlD,AAGE,IAAArC,qBACiBgI;AADjB,AAAA,oBAAAhI;AAAA,cAAAA,VACSmI;AADT,AAEE,IAAAC,WACE,iBAAMf,uBAAe,oBAAWgB,nBAAajB;AAA7C,AACE,YAAAkB,wCAAsB1H,GACpB,wBAAA,kOAAA,xOAAM6G,MAAK,0BAAA,uGAAA,/GAAIC,2FAAQD,KAAKC,kGAASD,oBACrCP,KAAKC,SACL,wBAAA,tBAAIE,8FAAgCD,SACpC,iBAAAzE,qBAAcuF;AAAd,AAAA,oBAAAvF;AAAA,AAAA,SAAAA,LAAW4F;AAAX,AAAuB,IAAA,AAAe,QAACA,mCAAAA,qCAAAA;gBAAhB,QAAAC,JAAoB9I;AAApB,AAAA;;AAAvB;;KACA,kDAAA,KAAA,iCAAA,tFACE,CAAY2C,UAAMoG,4CAClBpB,sBAAe,AAAoBhF,SACAA;GARvC,KAAA,KAAA;;AAFJ,AAAA,sFAAA+F,8BAAAA,5GAACD,wCAAAA,kDAAAA;;AAWDf;;;AA8DJ;;;;iCAAA,jCAAesB,0EAGZC;AAHH,AAIE,oBAAMA;AAAN,AACE,kBAAK9B;AAAL,AACE,IAAA+B,WACE,KAAAC,gBAAA;AAAA,AACE,IAAAC,aAA6DjC;IAA7DiC,iBAAA,AAAA9B,4BAAA8B;SAAA,AAAA/I,4CAAA+I,eAAA,hEAAclI;aAAd,AAAAb,4CAAA+I,eAAA,pEAAiBjI;WAAjB,AAAAd,4CAAA+I,eAAA,lEAAyB5B;eAAzB,AAAAnH,4CAAA+I,eAAA,tEAA8B3B;cAA9B,AAAApH,4CAAA+I,eAAA,rEAAuC1B;WAAvC,AAAArH,4CAAA+I,eAAA,lEAAgDjG;YAAhD,AAAA9C,4CAAA+I,eAAA,nEAAqDzG;IAArD0G,aACoBlI;WADpB,AAAA2G,4CAAAuB,WAAA,IAAA,lEACOtB;aADP,AAAAD,4CAAAuB,WAAA,IAAA,pEACYrB;IACNsB,OACA,KAAAH,gBAAA;AAAA,AACE,IAAM/H,MACA,IAAA,2VAAA,xRAA4BF,gDAC1B,wBAAA,yMAAA,/MAAM6G,MAAK,IAAA,gMAAA,hJAASA,kDAAK,0BAAA,6DAAA,rEAAMC,QAAO,IAAA,gDAASA,6EAC/C,KAAAC,eAAA,UAAA,KAAAA,eAAA,cAAA,KAAA,IAAA,OAAA,IAAA,3DAAMT,8BAAKC;AAHnB,AAKE,oBAAI9E;AACF,IAAMuF,YAAU,AAAChF,qBAAWP;AAA5B,AACE,GAAI,AAAA7B,2CAAA,RAAoB4G;AACtB,4MAAA,rJAAKtG,iDAAI2F,wEAAYA,iGAAsCmB;;AAC3D,4MAAA,rJAAK9G,iDAAI2F,wEAAYA,kGAAsCmB;;;AAC/D9G;;GAXN;AAHN,AAgBE,oEAAA,2CAAA,2DAAA,8DAAA,0DAAA,oDAAA,2CAAA,+DAAA,8DAAA,qFAAA,oDAAA,2CAAA,kGAAA,mDAAA,2CAAA,mDAAA,yDAAA,gFAAA,2CAAA,6TAAA,/4CAACiD,8JACQiF,sDACgC,KAAAnB,6DAChCX,0JACcC,+DACAC,6DACN,AAAC1F,eAAK0F,6KACHW,mLACNnH,uDAAU6G,8DAAcC,uHAE7B,6DAAA,KAAA,2CAAA,yFAAA,tMAAC3D,uKAA8BrD,mFAAWmC,kEAC1CR;GA5Bb;AADF,AAAA,0EAAAuG,wBAAAA,1FAACD,kCAAAA,4CAAAA;;;AAFL;;;AAiCF;;;4CAAA,5CAA4BM;AAA5B,AAA2EvI;;AAC3E;;;0BAAA,1BAA4BwI;AAA5B,AAA2ExI;;AAC3E;;;oCAAA,pCAA4ByI,gFAEzBR;AAFH,AAGW,QAAkBX,sDAAmC,AAACU,+BAAgBC;;AAYjF","names",["taoensso.truss/submap?","super-map","sub-map","cljs.core/reduce-kv","_","sub-key","sub-val","cljs.core/map?","super-val","cljs.core.get","temp__5823__auto__","match?","and__5140__auto__","cljs.core/reduced","pred-fn","cljs.core/fn?","G__22664","cljs.core/Keyword","cljs.core/keyword-identical?","cljs.core._EQ_","taoensso.truss/*ctx*","taoensso.truss/ex-info*","ns","coords","msg","data-map","cause","cljs.core.conj","ctx","cljs.core.assoc","cljs.core.ex_info","taoensso.truss/unexpected-arg!*","arg","kvs","or__5142__auto__","cljs.core.dissoc","cljs.core/type","taoensso.truss/set-ctx!","root-ctx-val","taoensso.truss/update-ctx","old-ctx","update-map-or-fn","cljs.core/ifn?","taoensso.truss/error?","x","js/Error","taoensso.truss/ex-root","error","cljs.core/ex-cause","taoensso.truss/ex-type","cljs.core/ExceptionInfo","cljs.core.symbol","taoensso.truss/ex-map*","temp__5825__auto__","cljs.core/ex-message","data","cljs.core/not-empty","cljs.core/ex-data","var_args","G__22757","taoensso.truss/ex-chain","taoensso.truss.ex_chain","as-maps?","xf","cljs.core/identity","acc","taoensso.truss/ex-map","chain","maps","cljs.core.mapv","root","cljs.core/peek","root-map","taoensso.truss.impl.assoc_some","st","G__22805","taoensso.truss/matching-error","kind","G__22809","cljs.core/set?","p1__22788#","taoensso.truss.impl/rsome","taoensso.truss.matching_error","pattern","p1__22791#","taoensso.truss.impl/str-contains?","taoensso.truss.impl/re-pattern?","cljs.core/re-find","get-default-error-fn","base-data","G__22868","taoensso.truss/catching-rf","rf","taoensso.truss.catching_rf","error-fn","e22880","t","G__22882","G__22883","e22884","G__22885","G__22886","in","e22889","G__22890","G__22891","k","v","e22892","G__22893","G__22894","G__22898","taoensso.truss/catching-xform","xform","cljs.core.comp","taoensso.truss/sys-newline","legacy-ex-data?","G__22906","taoensso.truss/failed-assertion-ex-info","failed-assertion-info","taoensso.truss.failed_assertion_ex_info","map__22907","cljs.core/--destructure-map","inst","pred","arg-form","arg-val","undefined-arg?","coords-str","vec__22908","cljs.core.nth","line","column","cljs.core/List","error-msg","js/Date","vec__22913","cljs.core/*assert*","taoensso.truss/*failed-assertion-handler*","taoensso.truss/failed-assertion!","data-fn","handler","G__22923","taoensso.truss.impl/ArgEvalError","taoensso.truss.impl/FailedAssertionInfo","df","e22925","taoensso.truss.impl/FalsePredError","taoensso.truss/legacy-error-fn","f","G__22941","cljs.core/Delay","map__22945","vec__22946","msg_","taoensso.truss/get-dynamic-assertion-data","taoensso.truss/get-data","taoensso.truss/set-error-fn!"]],"~:used-vars",["^[",["~$cljs.core/--destructure-map","~$cljs.core/comp","~$taoensso.truss.impl/FailedAssertionInfo","~$cljs.core/ex-message","~$taoensso.truss/*failed-assertion-handler*","~$cljs.core/=","~$taoensso.truss.impl/ArgEvalError","~$taoensso.truss.impl/FalsePredError","~$cljs.core/ifn?","~$js/Date","~$taoensso.truss/legacy-error-fn","~$taoensso.truss/failed-assertion-ex-info","~$taoensso.truss/get-dynamic-assertion-data","~$taoensso.truss/ex-type","~$cljs.core/*assert*","~$taoensso.truss/*ctx*","~$cljs.core/identity","~$cljs.core/Keyword","~$taoensso.truss/failed-assertion!","~$taoensso.truss/set-ctx!","~$cljs.core/mapv","~$cljs.core/dissoc","~$cljs.core/keyword-identical?","~$cljs.core/Delay","~$taoensso.truss/ex-chain","~$cljs.core/ExceptionInfo","~$cljs.core/map?","~$taoensso.truss.impl/str-contains?","~$cljs.core/conj","~$cljs.core/peek","~$cljs.core/fn?","~$taoensso.truss/unexpected-arg!*","~$taoensso.truss/ex-map*","~$cljs.core/List","~$taoensso.truss.impl/re-pattern?","~$taoensso.truss/catching-xform","~$cljs.core/get","~$cljs.core/not-empty","~$taoensso.truss/submap?","~$cljs.core/symbol","~$cljs.core/re-find","~$taoensso.truss/error?","~$taoensso.truss/get-data","~$taoensso.truss/catching-rf","~$cljs.core/reduced","~$cljs.core/set?","~$cljs.core/nth","~$cljs.core/ex-cause","~$cljs.core/ex-info","~$taoensso.truss/ex-root","~$taoensso.truss.impl/rsome","~$cljs.core/not","~$cljs.core/assoc","~$taoensso.truss.impl/assoc-some","~$taoensso.truss/set-error-fn!","~$cljs.core/ex-data","~$taoensso.truss/ex-map","~$cljs.core/reduce-kv","~$taoensso.truss/ex-info*","~$taoensso.truss/matching-error","~$taoensso.truss/sys-newline","~$taoensso.truss/update-ctx","~$js/Error","~$cljs.core/type"]]],"~:cache-keys",["~#cmap",[["^2L","taoensso/truss.cljc"],["6d232f99b0a31935a5a434460dd2080d9d86a15a","~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^[",[]],"~:deps-syms",["^2;","^27","^29"]]],["^2L","goog/dom/tagname.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","~$goog.dom.HtmlElement"]]],["^2L","goog/html/trustedtypes.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;"]]],["^2L","goog/labs/useragent/browser.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","~$goog.labs.userAgent.util","~$goog.labs.userAgent.highEntropy.highEntropyValue","~$goog.labs.userAgent.chromiumRebrands","~$goog.asserts","~$goog.string.internal","~$goog.labs.userAgent.highEntropy.highEntropyData","~$goog.labs.userAgent"]]],["^2L","goog/html/safeurl.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","^4L","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.string.Const","~$goog.string.TypedString","^4M"]]],["^2L","goog/array/array.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","^4L"]]],["^2L","goog/debug/error.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;"]]],["^2L","goog/flags/flags.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;"]]],["^2L","goog/dom/nodetype.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;"]]],["^2L","goog/labs/useragent/highentropy/highentropyvalue.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","^4I","^4M"]]],["^2L","taoensso/truss/impl.cljc"],["6d232f99b0a31935a5a434460dd2080d9d86a15a","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","^27","~$clojure.set"]]],["^2L","goog/string/typedstring.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;"]]],["^2L","goog/object/object.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;"]]],["^2L","goog/dom/asserts.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","^4L"]]],"~:SHADOW-TIMESTAMP",[1770361365000,1770361365000,1770361523000],["^2L","goog/math/long.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","^4L","~$goog.reflect"]]],["^2L","goog/html/trustedresourceurl.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","^4L","~$goog.fs.blob","^4P","~$goog.html.SafeScript","~$goog.html.trustedtypes","^4R","^4S"]]],["^2L","goog/string/internal.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;"]]],["^2L","goog/functions/functions.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;"]]],["^2L","goog/html/safestyle.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","^4R","~$goog.html.SafeUrl","^4S","^4L","^4M"]]],["^2L","goog/dom/safe.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","^4L","~$goog.asserts.dom","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","^4X","~$goog.html.SafeStyle","^4Z","^4Q","~$goog.html.uncheckedconversions","^4R","^4M"]]],["^2L","goog/asserts/dom.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","~$goog.dom.TagName","^4L","~$goog.dom.element"]]],["^2L","goog/html/safehtml.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","^4R","^4X","^53","~$goog.html.SafeStyleSheet","^4Z","^55","^4Q","^4S","^4L","~$goog.labs.userAgent.browser","~$goog.array","~$goog.object","^4M","~$goog.dom.tags","^4Y"]]],["^2L","goog/dom/tags.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","^5:"]]],["^2L","goog/fs/blob.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;"]]],["^2L","goog/asserts/asserts.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^2L","goog/uri/uri.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","^59","^4L","~$goog.collections.maps","~$goog.string","~$goog.structs","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^2L","goog/labs/useragent/highentropy/highentropydata.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","^4J"]]],["^2L","goog/collections/maps.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;"]]],["^2L","goog/fs/url.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;"]]],["^2L","goog/base.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",[]]],["^2L","goog/structs/structs.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","^59","^5:"]]],["^2L","goog/string/string.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","~$goog.dom.safe","^54","^4R","^4M"]]],["^2L","goog/reflect/reflect.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;"]]],["^2L","goog/labs/useragent/util.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","^4M","^4O"]]],["^2L","goog/string/stringbuffer.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;"]]],["^2L","goog/labs/useragent/chromium_rebrands.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;"]]],["^2L","goog/labs/useragent/useragent.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","~$goog.flags"]]],["^2L","goog/dom/element.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","^5=","^55"]]],["^2L","goog/html/uncheckedconversions.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","^4L","^52","^4X","^53","^57","^4Z","^4Q","^4R","^4M"]]],["^2L","goog/dom/htmlelement.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;"]]],["^2L","cljs/core.cljs"],["bb708c133efd2471c681d172c839d7d979202b70","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","~$goog.math.Long","~$goog.math.Integer","^5?","^5:","^59","~$goog.Uri","~$goog.string.StringBuffer"]]],["^2L","goog/html/safescript.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","^4R","^4S","^4Y","^4L"]]],["^2L","goog/html/safestylesheet.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","^4R","^53","^4S","^5:","^4L","^4M"]]],["^2L","goog/math/integer.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","^4V"]]],["^2L","clojure/set.cljs"],["bb708c133efd2471c681d172c839d7d979202b70","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","^27"]]],["^2L","goog/uri/utils.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","^4L","^5?"]]],["^2L","goog/string/const.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4D",["^ ","^4E",null,"^4F",["^[",[]],"^4G",["^2;","^4L","^4S"]]]]],"~:clj-info",["^ ","jar:file:/Users/davidwu/.m2/repository/org/clojure/clojure/1.12.4/clojure-1.12.4.jar!/clojure/java/io.clj",1766830591000,"jar:file:/Users/davidwu/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/analyzer/passes/and_or.cljc",1770361523000,"jar:file:/Users/davidwu/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/source_map.clj",1770361523000,"jar:file:/Users/davidwu/.m2/repository/com/taoensso/truss/2.2.0/truss-2.2.0.jar!/taoensso/truss.cljc",1764344475000,"jar:file:/Users/davidwu/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/core.cljc",1770361523000,"jar:file:/Users/davidwu/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/vendor/clojure/tools/reader/impl/errors.clj",1770361523000,"jar:file:/Users/davidwu/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/vendor/clojure/tools/reader/reader_types.clj",1770361523000,"jar:file:/Users/davidwu/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/compiler.cljc",1770361523000,"jar:file:/Users/davidwu/.m2/repository/org/clojure/clojure/1.12.4/clojure-1.12.4.jar!/clojure/instant.clj",1766830591000,"jar:file:/Users/davidwu/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/vendor/clojure/tools/reader.clj",1770361523000,"jar:file:/Users/davidwu/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/analyzer/impl/namespaces.cljc",1770361523000,"jar:file:/Users/davidwu/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/analyzer/passes/lite.cljc",1770361523000,"jar:file:/Users/davidwu/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/tagged_literals.cljc",1770361523000,"jar:file:/Users/davidwu/.m2/repository/org/clojure/clojure/1.12.4/clojure-1.12.4.jar!/clojure/edn.clj",1766830591000,"jar:file:/Users/davidwu/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/env.cljc",1770361523000,"jar:file:/Users/davidwu/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/analyzer/impl.cljc",1770361523000,"jar:file:/Users/davidwu/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/externs.clj",1770361523000,"jar:file:/Users/davidwu/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/analyzer.cljc",1770361523000,"jar:file:/Users/davidwu/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/vendor/clojure/data/json.clj",1770361523000,"jar:file:/Users/davidwu/.m2/repository/com/taoensso/truss/2.2.0/truss-2.2.0.jar!/taoensso/truss/impl.cljc",1764344475000,"jar:file:/Users/davidwu/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/vendor/clojure/tools/reader/impl/inspect.clj",1770361523000,"jar:file:/Users/davidwu/.m2/repository/org/clojure/clojure/1.12.4/clojure-1.12.4.jar!/clojure/pprint.clj",1766830591000,"jar:file:/Users/davidwu/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/instant.clj",1770361523000,"jar:file:/Users/davidwu/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/vendor/clojure/tools/reader/default_data_readers.clj",1770361523000,"jar:file:/Users/davidwu/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/source_map/base64_vlq.clj",1770361523000,"jar:file:/Users/davidwu/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/js_deps.cljc",1770361523000,"jar:file:/Users/davidwu/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/analyzer/passes.cljc",1770361523000,"jar:file:/Users/davidwu/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/source_map/base64.clj",1770361523000,"jar:file:/Users/davidwu/.m2/repository/org/clojure/clojure/1.12.4/clojure-1.12.4.jar!/clojure/core.clj",1766830591000,"jar:file:/Users/davidwu/.m2/repository/org/clojure/clojure/1.12.4/clojure-1.12.4.jar!/clojure/set.clj",1766830591000,"jar:file:/Users/davidwu/.m2/repository/org/clojure/clojure/1.12.4/clojure-1.12.4.jar!/clojure/string.clj",1766830591000,"jar:file:/Users/davidwu/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/util.cljc",1770361523000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","Peter Taoussanis (@ptaoussanis)","^7","A micro toolkit for Clojure/Script errors.","^8","taoensso/truss.cljc","^9",1,"^:",5,"^;",1,"^<",19],"^=",["^ ","^>","^?","^@","^A","^B","^C","^D","^E"],"^F",["^ ","^G","^H","^I","^H","^J","^H","^K","^H","^L","^H","^M","^H","^N","^H","^O","^H","^P","^H","^Q","^H","^R","^H","^S","^H","^T","^H","^U","^H","^V","^H","^W","^H","^X","^H","^Y","^H"],"^Z",["^[",["^T"]],"^10",["^ ","^G",["^ ","^11",["^12",[["^13","^14","^15"]]],"^7","Like `try`, but `catch` clause class may be:\n       `:ex-info` -- Catches only `ExceptionInfo`\n       `:common` --- Catches `js/Error` (Cljs), `Exception` (Clj)\n       `:all` ------ Catches `:default` (Cljs), `Throwable` (Clj)\n       `:default` -- Catches `:default` (Cljs), `Exception`, and `AssertionError` (Clj)\n                     but NOT other (usually critical) `Error`s\n\n     Addresses CLJ-1293 and the fact that `AssertionError`s are typically NON-critical\n     (so desirable to catch, in contrast to other `Error` classes).","^9",316,"^:",4,"^8","taoensso/truss.cljc","^16","^17","^18","^H","^19",true],"^I",["^ ","^1:",true,"^18","^H","^16","^1;","^8","taoensso/truss.cljc","^:",9,"^9",724,"^19",true,"^1<",true,"^11",["^12",[["^1=","~$&","^1>"]]],"^7","Prefer `*ctx*`"],"^J",["^ ","^11",["^12",[["^1?"],["^1@","^1?"],["^1@","^1A","^1?"]]],"^7","Evals `form` and if it throws an error that matches given criteria using\n     `matching-error`, returns true. Otherwise returns false.\n\n     Useful for unit tests, e.g.:\n       (is (throws? :default {:a :b}  (throw (ex-info \"MyEx\" {:a :b, :c :d})))) ; => true\n       (is (throws? :default \"MyEx\" (throw (ex-info \"MyEx\" {:a :b, :c :d})))) ; => true\n\n     See also `throws`, `matching-error`.","^9",451,"^:",4,"^8","taoensso/truss.cljc","^16","^1B","^18","^H","^19",true],"^K",["^ ","^11",["^12",[["^1C","~$&","^1>"]]],"^7","Evaluates given body with updated `*ctx*` value.\n\n  `update-map-or-fn` may be:\n    - A map to merge with    current `*ctx*` value, or\n    - A unary fn to apply to current `*ctx*` value\n\n  See `*ctx*` for details.","^9",199,"^:",1,"^8","taoensso/truss.cljc","^16","^1D","^18","^H","^19",true],"^L",["^ ","^1:",true,"^11",["^12",[["~$x"]]],"^9",58,"^:",9,"^8","taoensso/truss.cljc","^16","^1E","^18","^H","^19",true],"^M",["^ ","^11",["^12",[["~$x"],["^1F",["^12",["^1G"]],"~$x"],["^1F",["^12",["^1G"]],"~$x","~$&","^1H"]]],"^7","Main Truss assertion util.\n     Takes a (fn pred [x]) => truthy, and >=1 vals.\n     Tests pred against each val,trapping errors.\n\n     If any pred test fails, throws a detailed `truss/ex-info`.\n     Otherwise returns input val/s for convenient inline-use/binding.\n\n     Respects `*assert*`, so tests can be elided from production if desired\n     (meaning zero runtime cost).\n\n     Examples:\n       (defn my-trim [x] (str/trim (have string? x)))\n\n       ;; Add arb optional info to thrown ex-data using `:data`:\n       (have string? \"foo\" :data {:user-id 101}) => \"foo\"\n\n       ;; Assert inside collections using `:in`:\n       (have string? :in #{\"foo\" \"bar\"}) => #{\"foo\" \"bar\"}\n\n     Regarding use within other macros:\n       Due to CLJ-865, callsite info like line number of outer macro\n       will be lost. See `keep-callsite` for workaround.\n\n     See also `have?`, `have!`.","^9",620,"^:",4,"^8","taoensso/truss.cljc","^16","^1I","^18","^H","^19",true],"^N",["^ ","^11",["^12",[["^1J"]]],"^7","CLJ-865 means that it's not possible for an inner macro to access `&form`\n     metadata (incl. {:keys [line column]}) of a wrapping outer macro:\n\n       (defmacro inner [] (meta &form))\n       (defmacro outer [] `(inner))\n       (outer) => nil\n\n     This util offers a workaround for authors of the outer macro, preserving\n     the outer `&form` metadata for the inner macro:\n\n       (defmacro inner [] (meta &form))\n       (defmacro outer [] (keep-callsite `(inner)))\n       (outer) => {:keys [line column ...]}","^9",40,"^:",4,"^8","taoensso/truss.cljc","^16","^1K","^18","^H","^19",true],"^O",["^ ","^11",["^12",[["~$x"],["^1F",["^12",["^1G"]],"~$x"],["^1F",["^12",["^1G"]],"~$x","~$&","^1H"]]],"^7","Truss assertion util.\n     Like `have` but ignores `*assert*` value (so will never be elided).\n     Useful for important conditions in production (e.g. security checks).","^9",659,"^:",4,"^8","taoensso/truss.cljc","^16","^1L","^18","^H","^19",true],"^P",["^ ","^11",["^12",[["^1?"],["^1@","^1?"],["^1@","^1A","^1?"]]],"^7","Evals `form` and if it throws an error that matches given criteria using\n     `matching-error`, returns the matching error. Otherwise returns nil.\n\n     Useful for unit tests, e.g.:\n       (is (throws :default {:a :b}  (throw (ex-info \"MyEx\" {:a :b, :c :d})))) ; => ExceptionInfo\n       (is (throws :default \"MyEx\" (throw (ex-info \"MyEx\" {:a :b, :c :d})))) ; => ExceptionInfo\n\n     See also `throws?`, `matching-error`.","^9",437,"^:",4,"^8","taoensso/truss.cljc","^16","^1M","^18","^H","^19",true],"^Q",["^ ","^11",["^12",[["^1N"],["^1N","^1O"]]],"^7","Throws a `truss/ex-info` to indicate an unexpected argument:\n\n       (defn my-function [mode]\n         (case mode\n           :read  (do <...>)\n           :write (do <...>)\n           (unexpected-arg! mode\n             {:param       'mode\n              :context  `my-function\n              :expected #{:read :write}})))\n\n       (my-function :invalid-mode) => throws\n         Unexpected argument: :invalid-mode\n         {:param 'mode,\n          :arg {:value :unexpected, :type clojure.lang.Keyword},\n          :context 'my-ns/my-function,\n          :expected #{:read :write}\n          ...}","^9",149,"^:",4,"^8","taoensso/truss.cljc","^16","^1P","^18","^H","^19",true],"^R",["^ ","^11",["^12",[["~$x"],["^1F",["^12",["^1G"]],"~$x"],["^1F",["^12",["^1G"]],"~$x","~$&","^1H"]]],"^7","Truss assertion util.\n     Like `have` but returns `true` (rather than given arg value) on success.\n     Handy for `:pre`/`:post` conditions. Compare:\n       ((fn my-fn [] {:post [(have  nil? %)]} nil)) ; {:post [nil ]} FAILS\n       ((fn my-fn [] {:post [(have? nil? %)]} nil)) ; {:post [true]} passes as intended","^9",649,"^:",4,"^8","taoensso/truss.cljc","^16","^1Q","^18","^H","^19",true],"^S",["^ ","^11",["^12",[["^1R"],["^1R","^1S"],["^1R","^1S","^1T"]]],"^7","Throws a `truss/ex-info`.","^9",142,"^:",4,"^8","taoensso/truss.cljc","^16","^1U","^18","^H","^19",true],"^T",["^ ","^11",["^12",[["^1R"],["^1R","^1S"],["^1R","^1S","^1T"]]],"^7","Macro version of `core/ex-info` that adds extra keys to ex-info's data map:\n       `:truss/ctx` -- Value of dynamic `truss/*ctx*` when ex-info created\n       `:ns` --------- Namespace string of ex-info callsite\n       `:coords` ----- [line number]    of ex-info callsite, only present\n                       if ex-info isn't wrapped by another macro (or see\n                      `keep-callsite` for a workaround).","^9",130,"^:",4,"^8","taoensso/truss.cljc","^16","^1V","^18","^H","^19",true],"^U",["^ ","^1:",true,"^18","^H","^16","^1W","^8","taoensso/truss.cljc","^:",9,"^9",725,"^19",true,"^1<",true,"^11",["^12",[["^1=","~$&","^1>"]]],"^7","Prefer `*ctx*`"],"^V",["^ ","^11",["^12",[["^1X"],["^1Y","^1X"]]],"^7","Terse cross-platform util to swallow exceptions in `expr`.\n     Like (try* expr (catch :default _ nil)). See also `try*`.","^9",367,"^:",4,"^8","taoensso/truss.cljc","^16","^1Z","^18","^H","^19",true],"^W",["^ ","^11",["^12",[["~$x"],["^1F",["^12",["^1G"]],"~$x"],["^1F",["^12",["^1G"]],"~$x","~$&","^1H"]]],"^7","Truss assertion util.\n     Returns `true` (rather than given arg value) on success, and ignores\n     `*assert*` value (so will never be elided).\n  \n     **WARNING**: do NOT use in `:pre`/`:post` conditions since those ALWAYS\n     respect `*assert*`, contradicting the intention of the bang (`!`) here.","^9",667,"^:",4,"^8","taoensso/truss.cljc","^16","^1[","^18","^H","^19",true],"^X",["^ ","^1:",true,"^18","^H","^16","^20","^8","taoensso/truss.cljc","^:",4,"^9",727,"^19",true,"^1<",true,"^11",["^12",[["~$f","~$&","^1>"]]],"^7","Prefer `*failed-assertion-handler*` (note breaking changes to argument)."],"^Y",["^ ","^11",["^12",[["^21","~$&","^1>"]]],"^7","Evaluates given body with given `*ctx*` value. See `*ctx*` for details.","^9",182,"^:",1,"^8","taoensso/truss.cljc","^16","^22","^18","^H","^19",true]],"^16","^H","^23",["^ "],"^25",null,"^26",["^ ","^27","^27","^28","^27","^29","^29","^2:","^29","^2;","^2;"],"^2<",["^[",["^2=","^2>"]],"~:shadow/js-access-global",["^[",["Date","Error"]],"^2?",["^ ","^2@","^29","^2A","^29"],"~:defs",["^ ","~$catching-rf",["^ ","~:protocol-inline",null,"^5",["^ ","^8","taoensso/truss.cljc","^9",472,"^:",9,"^;",472,"^<",20,"^11",["^12",["~$quote",["^12",[["~$rf"],["~$error-fn","^6E"]]]]],"^7","Returns wrapper around given reducing function `rf` so that if `rf`\n    throws, (error-fn <thrown-error> <contextual-data>) will be called.\n\n    The default `error-fn` will rethrow the original error, wrapped in\n    extra contextual information to aid debugging.\n\n    Helps make reducing fns easier to debug!\n    See also `catching-xform`.","~:top-fn",["^ ","~:variadic?",false,"~:fixed-arity",2,"~:max-fixed-arity",2,"~:method-params",[["^6E"],["^6F","^6E"]],"^11",["^12",[["^6E"],["^6F","^6E"]]],"~:arglists-meta",["^12",[null,null]]]],"^16","^3Y","^8","taoensso/truss.cljc","^<",20,"^6G",["^ ","^6H",false,"^6I",2,"^6J",2,"^6K",[["^6E"],["^6F","^6E"]],"^11",["^12",[["^6E"],["^6F","^6E"]]],"^6L",["^12",[null,null]]],"^6K",[["^6E"],["^6F","^6E"]],"~:protocol-impl",null,"^6I",2,"^6L",["^12",[null,null]],"^:",3,"^6H",false,"~:methods",[["^ ","^6I",1,"^6H",false,"~:tag","~$any"],["^ ","^6I",2,"^6H",false,"^6O","~$function"]],"^9",472,"^;",472,"^6J",2,"~:fn-var",true,"^11",["^12",[["^6E"],["^6F","^6E"]]],"^7","Returns wrapper around given reducing function `rf` so that if `rf`\n    throws, (error-fn <thrown-error> <contextual-data>) will be called.\n\n    The default `error-fn` will rethrow the original error, wrapped in\n    extra contextual information to aid debugging.\n\n    Helps make reducing fns easier to debug!\n    See also `catching-xform`."],"~$error?",["^ ","^6C",null,"^5",["^ ","^8","taoensso/truss.cljc","^9",213,"^:",7,"^;",213,"^<",13,"^11",["^12",["^6D",["^12",[["~$x"]]]]],"^7","Returns true iff given platform error (`Throwable` or `js/Error`).","^6O",["^12",["^6D","~$boolean"]]],"^16","^3W","^8","taoensso/truss.cljc","^<",13,"^6K",["^12",[["~$x"]]],"^6M",null,"^6L",["^12",[null,null]],"^:",1,"^6H",false,"^9",213,"~:ret-tag",["^12",["^6D","^6T"]],"^;",213,"^6J",1,"^6O",["^12",["^6D","^6T"]],"^6R",true,"^11",["^12",["^6D",["^12",[["~$x"]]]]],"^7","Returns true iff given platform error (`Throwable` or `js/Error`)."],"~$get-data",["^ ","^1:",true,"^6C",null,"^5",["^ ","^1:",true,"^8","taoensso/truss.cljc","^<",37,"^:",29,"^9",717,"^1<",true,"^;",717,"^11",["^12",["^6D",["^12",[[]]]]],"^7","Prefer `*ctx*`"],"^16","^3X","^8","taoensso/truss.cljc","^<",37,"^6K",["^12",[[]]],"^6M",null,"^6L",["^12",[null,null]],"^:",1,"^6H",false,"^9",717,"^1<",true,"^6U","^6P","^;",717,"^6J",0,"^6R",true,"^11",["^12",["^6D",["^12",[[]]]]],"^7","Prefer `*ctx*`"],"~$submap?",["^ ","^1:",true,"^6C",null,"^5",["^ ","^8","taoensso/truss.cljc","^9",60,"^:",16,"^;",60,"^<",23,"^1:",true,"^11",["^12",["^6D",["^12",[["~$super-map","~$sub-map"]]]]],"^7","Returns true iff `sub-map` is a (possibly nested) submap of `super-map`,\n  i.e. iff every (nested) value in `sub-map` has the same (nested) value in `super-map`.\n\n  `sub-map` may contain special values:\n    `:submap/nx`     - Matches iff `super-map` does not contain key\n    `:submap/ex`     - Matches iff `super-map` does     contain key (any     val)\n    `:submap/some`   - Matches iff `super-map` does     contain key (non-nil val)\n    (fn [super-val]) - Matches iff given unary predicate returns truthy\n\n  Uses stack recursion so supports only limited nesting."],"^16","^3T","^8","taoensso/truss.cljc","^<",23,"^6K",["^12",[["^6X","^6Y"]]],"^6M",null,"^6L",["^12",[null,null]],"^:",1,"^6H",false,"^9",60,"^6U",["^[",[null,"^6P"]],"^;",60,"^6J",2,"^6R",true,"^11",["^12",["^6D",["^12",[["^6X","^6Y"]]]]],"^7","Returns true iff `sub-map` is a (possibly nested) submap of `super-map`,\n  i.e. iff every (nested) value in `sub-map` has the same (nested) value in `super-map`.\n\n  `sub-map` may contain special values:\n    `:submap/nx`     - Matches iff `super-map` does not contain key\n    `:submap/ex`     - Matches iff `super-map` does     contain key (any     val)\n    `:submap/some`   - Matches iff `super-map` does     contain key (non-nil val)\n    (fn [super-val]) - Matches iff given unary predicate returns truthy\n\n  Uses stack recursion so supports only limited nesting."],"~$catching-xform",["^ ","^6C",null,"^5",["^ ","^8","taoensso/truss.cljc","^9",505,"^:",7,"^;",505,"^<",21,"^11",["^12",["^6D",["^12",[["^6F","~$xform"],["^6["]]]]],"^7","Like `catching-rf`, but applies to a transducer (`xform`).\n\n  Helps make transductions much easier to debug by greatly improving\n  the info provided in any errors thrown by `xform` or the reducing fn:\n\n    (transduce\n      (catching-xform (comp (filter even?) (map inc))) ; Modified xform\n      <reducing-fn>\n      <...>)","^6G",["^ ","^6H",false,"^6I",2,"^6J",2,"^6K",[["^6F","^6["],["^6["]],"^11",["^12",[["^6F","^6["],["^6["]]],"^6L",["^12",[null,null]]]],"^16","^3Q","^8","taoensso/truss.cljc","^<",21,"^6G",["^ ","^6H",false,"^6I",2,"^6J",2,"^6K",[["^6F","^6["],["^6["]],"^11",["^12",[["^6F","^6["],["^6["]]],"^6L",["^12",[null,null]]],"^6K",[["^6F","^6["],["^6["]],"^6M",null,"^6I",2,"^6L",["^12",[null,null]],"^:",1,"^6H",false,"^6N",[["^ ","^6I",2,"^6H",false,"^6O","^6Q"],["^ ","^6I",1,"^6H",false,"^6O","^6Q"]],"^9",505,"^;",505,"^6J",2,"^6R",true,"^11",["^12",[["^6F","^6["],["^6["]]],"^7","Like `catching-rf`, but applies to a transducer (`xform`).\n\n  Helps make transductions much easier to debug by greatly improving\n  the info provided in any errors thrown by `xform` or the reducing fn:\n\n    (transduce\n      (catching-xform (comp (filter even?) (map inc))) ; Modified xform\n      <reducing-fn>\n      <...>)"],"~$ex-chain",["^ ","^1:",true,"^6C",null,"^5",["^ ","^1:",true,"^8","taoensso/truss.cljc","^<",24,"^6G",["^ ","^6H",false,"^6I",2,"^6J",2,"^6K",[["~$x"],["~$as-maps?","~$x"]],"^11",["^12",[["~$x"],["^71","~$x"]]],"^6L",["^12",[null,null]]],"^:",16,"^9",253,"^;",253,"^11",["^12",["^6D",["^12",[["~$x"],["^71","~$x"]]]]],"^7","Private, don't use.\n  Returns vector cause chain of given platform error."],"^16","^3F","^8","taoensso/truss.cljc","^<",24,"^6G",["^ ","^6H",false,"^6I",2,"^6J",2,"^6K",[["~$x"],["^71","~$x"]],"^11",["^12",[["~$x"],["^71","~$x"]]],"^6L",["^12",[null,null]]],"^6K",[["~$x"],["^71","~$x"]],"^6M",null,"^6I",2,"^6L",["^12",[null,null]],"^:",1,"^6H",false,"^6N",[["^ ","^6I",1,"^6H",false,"^6O","^6P"],["^ ","^6I",2,"^6H",false,"^6O",["^[",["~$clj","~$cljs.core/IVector","~$clj-nil"]]]],"^9",253,"^;",253,"^6J",2,"^6R",true,"^11",["^12",[["~$x"],["^71","~$x"]]],"^7","Private, don't use.\n  Returns vector cause chain of given platform error."],"~$ex-info*",["^ ","^1:",true,"^6C",null,"^5",["^ ","^8","taoensso/truss.cljc","^9",106,"^:",16,"^;",106,"^<",24,"^1:",true,"^11",["^12",["^6D",["^12",[["^2C","~$coords","^1R","^1S","^1T"]]]]],"^7","Private, don't use."],"^16","^4<","^8","taoensso/truss.cljc","^<",24,"^6K",["^12",[["^2C","^76","^1R","^1S","^1T"]]],"^6M",null,"^6L",["^12",[null,null]],"^:",1,"^6H",false,"^9",106,"^6U","^3G","^;",106,"^6J",5,"^6R",true,"^11",["^12",["^6D",["^12",[["^2C","^76","^1R","^1S","^1T"]]]]],"^7","Private, don't use."],"~$sys-newline",["^ ","^5",["^ ","^8","taoensso/truss.cljc","^9",521,"^:",16,"^;",521,"^<",27,"~:private",true],"^78",true,"^16","^4>","^8","taoensso/truss.cljc","^<",27,"^:",1,"^9",521,"^;",521,"^6O","~$string"],"~$ex-root",["^ ","^1:",true,"^6C",null,"^5",["^ ","^8","taoensso/truss.cljc","^9",220,"^:",16,"^;",220,"^<",23,"^1:",true,"^11",["^12",["^6D",["^12",[["~$x"]]]]],"^7","Private, don't use.\n  Returns root cause of given platform error."],"^16","^43","^8","taoensso/truss.cljc","^<",23,"^6K",["^12",[["~$x"]]],"^6M",null,"^6L",["^12",[null,null]],"^:",1,"^6H",false,"^9",220,"^6U",["^[",[null,"^74"]],"^;",220,"^6J",1,"^6R",true,"^11",["^12",["^6D",["^12",[["~$x"]]]]],"^7","Private, don't use.\n  Returns root cause of given platform error."],"~$matching-error",["^ ","^6C",null,"^5",["^ ","^8","taoensso/truss.cljc","^9",375,"^:",7,"^;",375,"^<",21,"^11",["^12",["^6D",["^12",[["~$error"],["^1@","^7<"],["^1@","^1A","^7<"]]]]],"^7","Given a platform error and criteria for matching, returns the error if it\n  matches all criteria. Otherwise returns nil.\n\n  `kind` may be:\n    - A class (`ArithmeticException`, `AssertionError`, etc.)\n    - A special keyword as given to `try*` (`:default`, `:common`, `:ex-info`, `:all`)\n    - A set of `kind`s  as above, at least one of which must match\n    - A predicate function, (fn match? [x]) -> bool\n\n  `pattern` may be:\n    - A string or Regex against which `ex-message` must match\n    - A map             against which `ex-data`    must match using `submap?`\n    - A set of `pattern`s as above, at least one of which must match\n\n  When an error with (nested) causes doesn't match, a match will be attempted\n  against its (nested) causes.\n\n  This is a low-level util, see also `throws`, `throws?`.","^6G",["^ ","^6H",false,"^6I",3,"^6J",3,"^6K",[["^7<"],["^1@","^7<"],["^1@","^1A","^7<"]],"^11",["^12",[["^7<"],["^1@","^7<"],["^1@","^1A","^7<"]]],"^6L",["^12",[null,null,null]]]],"^16","^4=","^8","taoensso/truss.cljc","^<",21,"^6G",["^ ","^6H",false,"^6I",3,"^6J",3,"^6K",[["^7<"],["^1@","^7<"],["^1@","^1A","^7<"]],"^11",["^12",[["^7<"],["^1@","^7<"],["^1@","^1A","^7<"]]],"^6L",["^12",[null,null,null]]],"^6K",[["^7<"],["^1@","^7<"],["^1@","^1A","^7<"]],"^6M",null,"^6I",3,"^6L",["^12",[null,null,null]],"^:",1,"^6H",false,"^6N",[["^ ","^6I",1,"^6H",false],["^ ","^6I",2,"^6H",false,"^6O",["^[",[null,"^74"]]],["^ ","^6I",3,"^6H",false,"^6O",["^[",[null,"^6P","^74"]]]],"^9",375,"^;",375,"^6J",3,"^6R",true,"^11",["^12",[["^7<"],["^1@","^7<"],["^1@","^1A","^7<"]]],"^7","Given a platform error and criteria for matching, returns the error if it\n  matches all criteria. Otherwise returns nil.\n\n  `kind` may be:\n    - A class (`ArithmeticException`, `AssertionError`, etc.)\n    - A special keyword as given to `try*` (`:default`, `:common`, `:ex-info`, `:all`)\n    - A set of `kind`s  as above, at least one of which must match\n    - A predicate function, (fn match? [x]) -> bool\n\n  `pattern` may be:\n    - A string or Regex against which `ex-message` must match\n    - A map             against which `ex-data`    must match using `submap?`\n    - A set of `pattern`s as above, at least one of which must match\n\n  When an error with (nested) causes doesn't match, a match will be attempted\n  against its (nested) causes.\n\n  This is a low-level util, see also `throws`, `throws?`."],"~$set-error-fn!",["^ ","^1:",true,"^6C",null,"^5",["^ ","^1:",true,"^8","taoensso/truss.cljc","^<",42,"^:",29,"^9",718,"^1<",true,"^;",718,"^11",["^12",["^6D",["^12",[["~$f"]]]]],"^7","Prefer `*failed-assertion-handler*` (note breaking changes to argument)."],"^16","^48","^8","taoensso/truss.cljc","^<",42,"^6K",["^12",[["~$f"]]],"^6M",null,"^6L",["^12",[null,null]],"^:",1,"^6H",false,"^9",718,"^1<",true,"^;",718,"^6J",1,"^6R",true,"^11",["^12",["^6D",["^12",[["~$f"]]]]],"^7","Prefer `*failed-assertion-handler*` (note breaking changes to argument)."],"~$*ctx*",["^ ","^5",["^ ","^8","taoensso/truss.cljc","^9",96,"^:",16,"^;",96,"^<",21,"~:dynamic",true],"^16","^3=","^8","taoensso/truss.cljc","^<",21,"^:",1,"^7?",true,"^9",96,"^;",96,"^6O","^6P","^7","Context map to assoc to `:truss/ctx` key of `truss/ex-info` data map.\n\n  Re/bind dynamic        value using `with-ctx`, `with-ctx+`, or `binding`.\n  Modify  root (default) value using `set-ctx!`.\n\n  As with all dynamic Clojure vars, \"binding conveyance\" applies when\n  using futures, agents, etc."],"~$update-ctx",["^ ","^1:",true,"^6C",null,"^5",["^ ","^8","taoensso/truss.cljc","^9",186,"^:",16,"^;",186,"^<",26,"^1:",true,"^11",["^12",["^6D",["^12",[["~$old-ctx","^1C"]]]]],"^7","Returns `new-ctx` given `old-ctx` and an update map or fn."],"^16","^4?","^8","taoensso/truss.cljc","^<",26,"^6K",["^12",[["^7A","^1C"]]],"^6M",null,"^6L",["^12",[null,null]],"^:",1,"^6H",false,"^9",186,"^6U",["^[",[null,"^72","^6P"]],"^;",186,"^6J",2,"^6R",true,"^11",["^12",["^6D",["^12",[["^7A","^1C"]]]]],"^7","Returns `new-ctx` given `old-ctx` and an update map or fn."],"~$ex-type",["^ ","^1:",true,"^6C",null,"^5",["^ ","^8","taoensso/truss.cljc","^9",232,"^:",16,"^;",232,"^<",23,"^1:",true,"^11",["^12",["^6D",["^12",[["~$x"]]]]],"^7","Private, don't use.\n  Returns class symbol of given platform error."],"^16","^3;","^8","taoensso/truss.cljc","^<",23,"^6K",["^12",[["~$x"]]],"^6M",null,"^6L",["^12",[null,null]],"^:",1,"^6H",false,"^9",232,"^6U",["^[",["~$cljs.core/Symbol","^74"]],"^;",232,"^6J",1,"^6R",true,"^11",["^12",["^6D",["^12",[["~$x"]]]]],"^7","Private, don't use.\n  Returns class symbol of given platform error."],"~$failed-assertion-ex-info",["^ ","^6C",null,"^5",["^ ","^8","taoensso/truss.cljc","^9",525,"^:",9,"^;",525,"^<",33,"^11",["^12",["^6D",["^12",[["~$failed-assertion-info"],["~$legacy-ex-data?","^7E"]]]]],"^7","Returns an appropriate `truss/ex-info` for given failed assertion info map.","^6G",["^ ","^6H",false,"^6I",2,"^6J",2,"^6K",[["^7E"],["^7F","^7E"]],"^11",["^12",[["^7E"],["^7F","^7E"]]],"^6L",["^12",[null,null]]]],"^16","^39","^8","taoensso/truss.cljc","^<",33,"^6G",["^ ","^6H",false,"^6I",2,"^6J",2,"^6K",[["^7E"],["^7F","^7E"]],"^11",["^12",[["^7E"],["^7F","^7E"]]],"^6L",["^12",[null,null]]],"^6K",[["^7E"],["^7F","^7E"]],"^6M",null,"^6I",2,"^6L",["^12",[null,null]],"^:",3,"^6H",false,"^6N",[["^ ","^6I",1,"^6H",false,"^6O","^6P"],["^ ","^6I",2,"^6H",false,"^6O","^3G"]],"^9",525,"^;",525,"^6J",2,"^6R",true,"^11",["^12",[["^7E"],["^7F","^7E"]]],"^7","Returns an appropriate `truss/ex-info` for given failed assertion info map."],"~$*failed-assertion-handler*",["^ ","^6C",null,"^5",["^ ","^8","taoensso/truss.cljc","^9",575,"^:",16,"^;",575,"^<",42,"^7?",true],"^16","^32","^8","taoensso/truss.cljc","^<",42,"^6K",["^12",[["^7E"]]],"^6M",null,"^6L",["^12",[]],"^:",1,"^6H",false,"^7?",true,"^9",575,"^6U","~$ignore","^;",575,"^6J",1,"^6R",true,"^11",null,"^7","Unary handler fn to call with failed assertion info map when a Truss\n  assertion (`have`, `have?`, `have!`, `have!?`) fails.\n\n  Will by default throw an appropriate `truss/ex-info`.\n  This is a decent place to inject logging for assertion failures, etc.\n\n  Arg given to handler is a map with keys:\n\n  `:ns` ----------- ?str namespace of assertion callsite\n  `:coords` ------- ?[line column] of assertion callsite\n\n  `:pred` --------- Assertion predicate form  (e.g. `clojure.core/string?` sym)\n  `:arg-form` ----- Assertion argument  form given  to predicate (e.g. `x` sym)\n  `:arg-val` ------ Runtime value of argument given to predicate\n\n  `:data` --------- Optional arbitrary data map provided to assertion macro\n  `:error` -------- `Throwable` or `js/Error` thrown evaluating predicate"],"~$get-dynamic-assertion-data",["^ ","^1:",true,"^6C",null,"^5",["^ ","^1:",true,"^8","taoensso/truss.cljc","^<",55,"^:",29,"^9",716,"^1<",true,"^;",716,"^11",["^12",["^6D",["^12",[[]]]]],"^7","Prefer `*ctx*`"],"^16","^3:","^8","taoensso/truss.cljc","^<",55,"^6K",["^12",[[]]],"^6M",null,"^6L",["^12",[null,null]],"^:",1,"^6H",false,"^9",716,"^1<",true,"^6U","^6P","^;",716,"^6J",0,"^6R",true,"^11",["^12",["^6D",["^12",[[]]]]],"^7","Prefer `*ctx*`"],"~$legacy-error-fn",["^ ","^1:",true,"^6C",null,"^5",["^ ","^8","taoensso/truss.cljc","^9",679,"^:",16,"^;",679,"^<",31,"^1:",true,"^11",["^12",["^6D",["^12",[["~$f"]]]]],"^7","Private, don't use. Wraps given Truss v1 `error-fn` to convert\n  Truss v2 `*failed-assertion-handler*` arg."],"^16","^38","^8","taoensso/truss.cljc","^<",31,"^6K",["^12",[["~$f"]]],"^6M",null,"^6L",["^12",[null,null]],"^:",1,"^6H",false,"^9",679,"^6U",["^[",["^6Q","^74"]],"^;",679,"^6J",1,"^6R",true,"^11",["^12",["^6D",["^12",[["~$f"]]]]],"^7","Private, don't use. Wraps given Truss v1 `error-fn` to convert\n  Truss v2 `*failed-assertion-handler*` arg."],"~$ex-map",["^ ","^1:",true,"^6C",null,"^5",["^ ","^8","taoensso/truss.cljc","^9",280,"^:",16,"^;",280,"^<",22,"^1:",true,"^11",["^12",["^6D",["^12",[["~$x"]]]]],"^7","Private, don't use.\n  Returns ?{:keys [type msg data chain trace]} for given platform error."],"^16","^4:","^8","taoensso/truss.cljc","^<",22,"^6K",["^12",[["~$x"]]],"^6M",null,"^6L",["^12",[null,null]],"^:",1,"^6H",false,"^9",280,"^6U",["^[",[null,"^6P","^74"]],"^;",280,"^6J",1,"^6R",true,"^11",["^12",["^6D",["^12",[["~$x"]]]]],"^7","Private, don't use.\n  Returns ?{:keys [type msg data chain trace]} for given platform error."],"~$set-ctx!",["^ ","^6C",null,"^5",["^ ","^8","taoensso/truss.cljc","^9",176,"^:",7,"^;",176,"^<",15,"^11",["^12",["^6D",["^12",[["~$root-ctx-val"]]]]],"^7","Set `*ctx*` var's default (root) value. See `*ctx*` for details."],"^16","^3A","^8","taoensso/truss.cljc","^<",15,"^6K",["^12",[["^7M"]]],"^6M",null,"^6L",["^12",[null,null]],"^:",1,"^6H",false,"^9",176,"^;",176,"^6J",1,"^6R",true,"^11",["^12",["^6D",["^12",[["^7M"]]]]],"^7","Set `*ctx*` var's default (root) value. See `*ctx*` for details."],"~$unexpected-arg!*",["^ ","^1:",true,"^6C",null,"^5",["^ ","^8","taoensso/truss.cljc","^9",121,"^:",16,"^;",121,"^<",32,"^1:",true,"^11",["^12",["^6D",["^12",[["^2C","^76","^1N","^1O"]]]]],"^7","Private, don't use."],"^16","^3M","^8","taoensso/truss.cljc","^<",32,"^6K",["^12",[["^2C","^76","^1N","^1O"]]],"^6M",null,"^6L",["^12",[null,null]],"^:",1,"^6H",false,"^9",121,"^6U","^7H","^;",121,"^6J",4,"^6R",true,"^11",["^12",["^6D",["^12",[["^2C","^76","^1N","^1O"]]]]],"^7","Private, don't use."],"~$ex-map*",["^ ","^1:",true,"^6C",null,"^5",["^ ","^8","taoensso/truss.cljc","^9",242,"^:",16,"^;",242,"^<",23,"^1:",true,"^11",["^12",["^6D",["^12",[["~$x"]]]]],"^7","Private, don't use.\n  Returns ?{:keys [type msg data]} for given platform error."],"^16","^3N","^8","taoensso/truss.cljc","^<",23,"^6K",["^12",[["~$x"]]],"^6M",null,"^6L",["^12",[null,null]],"^:",1,"^6H",false,"^9",242,"^6U",["^[",["~$cljs.core/IMap","^74"]],"^;",242,"^6J",1,"^6R",true,"^11",["^12",["^6D",["^12",[["~$x"]]]]],"^7","Private, don't use.\n  Returns ?{:keys [type msg data]} for given platform error."],"~$failed-assertion!",["^ ","^1:",true,"^6C",null,"^5",["^ ","^8","taoensso/truss.cljc","^9",601,"^:",16,"^;",601,"^<",33,"^1:",true,"^11",["^12",["^6D",["^12",[["^2C","~$line","~$column","^1F","~$arg-form","~$arg-val","~$data-fn","^7<"]]]]],"^7","Private, don't use."],"^16","^3@","^8","taoensso/truss.cljc","^<",33,"^6K",["^12",[["^2C","^7R","^7S","^1F","^7T","^7U","^7V","^7<"]]],"^6M",null,"^6L",["^12",[null,null]],"^:",1,"^6H",false,"^9",601,"^6U",["^[",[null,"^6P"]],"^;",601,"^6J",8,"^6R",true,"^11",["^12",["^6D",["^12",[["^2C","^7R","^7S","^1F","^7T","^7U","^7V","^7<"]]]]],"^7","Private, don't use."]],"^2>",["^ ","^H","^H","^27","^27","^28","^27","^29","^29","^2:","^29"],"~:cljs.analyzer/constants",["^ ","^2<",["^[",["~:args","~$set","~:given","~:rf","~:v","~$map","~:pred","~:inst","~:else","~:call","~$in","^1A","~:truss/ctx","~:coords","~:default","~:acc","~:msg_","^18","~:trace","~$re-pattern","~:dt","~:value","^6E","~$v","^3G","~:err","~$fn","~:msg","~:type","~:arg-form","~:truss/exception","~:env","~:all","~:param","~:k","^:","~$acc","~:arg-val","~:common","~:ex-info","^7?","^9","~:arg","~:*assert*","~:error/msg","~:chain","~:expected","^79","~$k","~:context","^1C","~:error","^2B","~:loc","^4=","^4?","^1G","~:taoensso.truss/nx","~:data"]],"~:order",["^8T","^18","^87","^86","^8A","^8L","^8>","^8B","^83","^8G","^8Q","^8P","^1C","^4?","^80","^8@","^3G","^8U","^8O","^8;","^7Z","^88","^8F","^8J","^8K","^1A","^4=","^7Y","^8<","^79","^8N","^7[","^84","^6E","^7X","^8H","^89","^85","^1G","~$k","~$v","~:k","~:v","^82","^81","^8C","^8I","^8R","^8D","^8=","^8S","^8E","^9","^:","^7?","^8M","^2B","^8:","^8?"]],"^2H",["^ ","^2=",["^[",[]],"^2>",["^[",[]]],"^2I",[],"^2J",["^2;","^27","^29"]],"^18","^H","~:ns-specs",["^ "],"~:ns-spec-vars",["^[",[]],"~:compiler-options",["^4C",[["^8Y","~:static-fns"],true,["~:js-options","~:use-babel"],null,["^8Y","~:lite-mode"],null,["^8Y","~:shadow-tweaks"],null,["^8Y","~:source-map-inline"],null,["^8Y","~:shadow-optimize-constants"],null,["^8Y","~:elide-asserts"],true,["^8Y","~:optimize-constants"],null,["^8Y","^2O"],null,["^8Y","~:external-config"],null,["^8Y","~:tooling-config"],null,["^8Y","~:emit-constants"],null,["^8Y","~:load-tests"],false,["^8Y","~:form-size-threshold"],null,["^8Y","~:global-goog-object&array"],null,["^8Y","~:data-readers"],null,["~:shadow.build/config","~:target"],"~:browser",["^8Y","~:infer-externs"],"~:auto",["^8Y","^2Q"],null,["^8[","~:js-provider"],"~:shadow",["~:mode"],"~:release",["^8Y","~:fn-invoke-direct"],null,["^8Y","~:elide-to-string"],null,["^8Y","~:source-map"],null]]]