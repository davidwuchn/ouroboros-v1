{:deps {;; Engine -> substrate: explicit, queryable state machines
        com.fulcrologic/statecharts                   {:mvn/version "1.2.25"}
        ;; Query + Graph: EQL interface to everything
        com.wsscode/pathom3                           {:mvn/version "2025.01.16-alpha"}
        ;; API: OpenAPI specs -> callable clients
        com.github.oliyh/martian-babashka-http-client {:mvn/version "0.2.1"}
        org.babashka/http-client                      {:mvn/version "0.4.23"}
        ;; JSON encoding
        cheshire/cheshire                             {:mvn/version "5.13.0"}
        ;; WebSocket support (for Clojure, not Babashka)
        http-kit/http-kit                             {:mvn/version "2.8.0"}}

 :paths ["src" "test" "src/frontend"]

 :tasks
 {:requires ([clojure.string :as str]
             [babashka.process :refer [shell process]])
  ;; ==========================================================================
  ;; Core Tasks
  ;; ==========================================================================
  ;; nREPL convention: port 8888 (use 888X for parallel playthroughs)

  boot
  {:doc "Boot the Ouroboros system (Engine + Query)"
   :requires ([ouroboros.interface :as iface])
   :task (do (println "Booting Ouroboros system...")
             (iface/boot!)
             (println "\nSystem ready")
             (println "  Query: (iface/q [:system/status])")
             (println "  Status: (iface/status)"))}

  nrepl
  {:doc "Start nREPL on port 8888 with system pre-booted"
   :requires ([babashka.nrepl.server :as nrepl]
             [ouroboros.interface :as iface])
   :task (do (println "Booting system...")
             (iface/boot!)
             (println "Starting nREPL on port 8888...")
             (println "  Pre-loaded: ouroboros.interface")
             (println "  Try: (iface/q [:system/status])")
             (nrepl/start-server! {:host "localhost"
                                   :port 8888})
             (deref (promise)))}

  chat
  {:doc "Start chat bots from environment configuration (.env or env vars)"
   :requires ([ouroboros.config :as config])
   :task (config/start-from-env!)}

  ;; ==========================================================================
  ;; Dashboard Tasks
  ;; ==========================================================================

  dashboard
  {:doc "Start the web dashboard server (requires Clojure, not Babashka)"
   :task (do (println "Dashboard server requires Clojure (deps.edn)")
             (println "Run: clojure -M -m ouroboros.dashboard")
             (println "Or use: bb nrepl and start manually"))}

  ;; ==========================================================================
  ;; Frontend Tasks
  ;; ==========================================================================

  frontend:dev
  {:doc "Start shadow-cljs development server"
   :task (shell "npx shadow-cljs watch dashboard")}

  frontend:build
  {:doc "Build frontend for production"
   :task (shell "npx shadow-cljs release dashboard")}

  frontend:server
  {:doc "Start shadow-cljs server only"
   :task (shell "npx shadow-cljs server")}

  frontend:install
  {:doc "Install npm dependencies"
   :task (shell "npm install")}

  ;; ==========================================================================
  ;; Development Tasks
  ;; ==========================================================================

  config
  {:doc "Show configuration summary (safe to log)"
   :requires ([ouroboros.config :as config])
   :task (do (config/load-config!)
             (clojure.pprint/pprint (config/config-summary)))}

  ;; ==========================================================================
  ;; Git Hooks
  ;; ==========================================================================

  git:install-hooks
  {:doc "Install git hooks (pre-commit test runner)"
   :task (do (let [source "scripts/git-hooks/pre-commit"
                   target ".git/hooks/pre-commit"]
               (if (babashka.fs/exists? source)
                 (do
                   (babashka.fs/copy source target {:replace-existing true})
                   (babashka.fs/set-posix-file-permissions target "rwxr-xr-x")
                   (println "Pre-commit hook installed")
                   (println "  Tests will run before each commit")
                   (println "  Bypass with: git commit --no-verify"))
                 (do
                   (println "Hook source not found:")
                   (println "  " source)))))}

  ;; ==========================================================================
  ;; Analysis Tasks
  ;; ==========================================================================

   audit:ns
   {:doc "Audit namespace dependency graph (circular deps, fan-in, depth)"
    :task (shell "bb scripts/ns-audit.clj")}

   ;; ==========================================================================
   ;; Utility Tasks
   ;; ==========================================================================

   download
   {:doc "Fast download with auto-resume (usage: bb download <url> [file] [-c 16])"
    :task (let [args *command-line-args*]
            (if (seq args)
              (apply shell "bb" "scripts/fast-download.clj" args)
              (do
                (println "Usage: bb download <url> [output-file] [options]")
                (println "")
                (println "Options:")
                (println "  -c, --connections N  Number of parallel connections (default: 16)")
                (println "  -s, --splits N       Number of splits (default: 16)")
                (println "")
                (println "Examples:")
                (println "  bb download https://example.com/file.zip")
                (println "  bb download https://example.com/file.zip my-file.zip")
                (println "  bb download https://example.com/file.zip -c 32"))))}

   ;; ==========================================================================
   ;; Testing Tasks
   ;; ==========================================================================

  test
  {:doc "Run all system tests (core, chat, tools, webux, integration)"
   :requires ([clojure.test :as t])
   :task (do (println "\n========================================")
             (println "  Running All Test Suites")
             (println "========================================")
             (println "NOTE: WebUX tests with WebSocket deps run separately")
             (println "      Run: bb test:webux (requires Clojure, not Babashka)")
             (println "NOTE: ECA integration tests require manual execution")
             (println "      Run: bb test:eca (requires ECA binary installed)\n")
              (require 'ouroboros.core-test)
              (require 'ouroboros.chat-adapter-test)
              (require 'ouroboros.tool-execution-test)
              (require 'ouroboros.integration-test)
              (let [sum-results (fn [results]
                                  {:test (apply + (map :test results))
                                   :pass (apply + (map :pass results))
                                   :fail (apply + (map :fail results))
                                   :error (apply + (map :error results))})
                    results (sum-results
                             [(t/run-tests 'ouroboros.core-test)
                              (t/run-tests 'ouroboros.chat-adapter-test)
                              (t/run-tests 'ouroboros.tool-execution-test)
                              (t/run-tests 'ouroboros.integration-test)])]
               (println "\n========================================")
               (println "  Grand Total")
               (println "========================================")
               (println (str "  Tests: " (:test results)))
               (println (str "  Assertions: " (:pass results)))
               (println (str "  Failures: " (:fail results)))
               (println (str "  Errors: " (:error results)))
               (when (and (zero? (:fail results))
                          (zero? (:error results)))
                 (println "\n  ALL TESTS PASSED!"))
               (System/exit (if (and (zero? (:fail results))
                                     (zero? (:error results)))
                              0 1))))}

  test:webux
  {:doc "Run WebUX Platform tests (requires Clojure, not Babashka)"
   :requires ([clojure.test :as t])
   :task (do (println "\n========================================")
             (println "  Running WebUX Platform Tests")
             (println "========================================")
             (println "NOTE: These tests require Clojure (deps.edn)")
             (println "      Some tests use http-kit WebSocket server\n")
              (require 'ouroboros.webux-test)
              (require 'ouroboros.wisdom-test)
              (require 'ouroboros.analytics-test)
              ;; These require WebSocket/HTTP-kit:
              ;; (require 'ouroboros.collaboration-test)
              ;; (require 'ouroboros.offline-sync-test)
              ;; (require 'ouroboros.embed-test)
              (let [sum-results (fn [results]
                                  {:test (apply + (map :test results))
                                   :pass (apply + (map :pass results))
                                   :fail (apply + (map :fail results))
                                   :error (apply + (map :error results))})
                    results (sum-results
                             [(t/run-tests 'ouroboros.webux-test)
                              (t/run-tests 'ouroboros.wisdom-test)
                              (t/run-tests 'ouroboros.analytics-test)])]
               (println "\n========================================")
               (println "  WebUX Test Results")
               (println "========================================")
               (println (str "  Tests: " (:test results)))
               (println (str "  Assertions: " (:pass results)))
               (println (str "  Failures: " (:fail results)))
               (println (str "  Errors: " (:error results)))
               (when (and (zero? (:fail results))
                          (zero? (:error results)))
                 (println "\n  ALL WEBUX TESTS PASSED!"))
               (System/exit (if (and (zero? (:fail results))
                                     (zero? (:error results)))
                              0 1))))}

  test:eca
  {:doc "Run ECA integration tests (requires ECA binary installed)"
   :requires ([clojure.test :as t])
   :task (do (println "\n========================================")
             (println "  Running ECA Integration Tests")
             (println "========================================")
             (println "⚠️  Requires: ECA binary installed")
             (println "   Download from: https://github.com/editor-code-assistant/eca/releases\n")
             (require 'ouroboros.eca-client-test)
             (require 'ouroboros.eca-approval-bridge-test)
             (require 'ouroboros.eca-integration-test)
             (require 'ouroboros.eca-protocol-test)
             (let [sum-results (fn [results]
                                 {:test (apply + (map :test results))
                                  :pass (apply + (map :pass results))
                                  :fail (apply + (map :fail results))
                                  :error (apply + (map :error results))})
                   results (sum-results
                            [(t/run-tests 'ouroboros.eca-client-test)
                             (t/run-tests 'ouroboros.eca-approval-bridge-test)
                             (t/run-tests 'ouroboros.eca-integration-test)
                             (t/run-tests 'ouroboros.eca-protocol-test)])]
               (println "\n========================================")
               (println "  ECA Test Results")
               (println "========================================")
               (println (str "  Tests: " (:test results)))
               (println (str "  Assertions: " (:pass results)))
               (println (str "  Failures: " (:fail results)))
               (println (str "  Errors: " (:error results)))
               (when (and (zero? (:fail results))
                          (zero? (:error results)))
                 (println "\n  ALL ECA TESTS PASSED!"))
               (System/exit (if (and (zero? (:fail results))
                                     (zero? (:error results)))
                              0 1))))}}}
