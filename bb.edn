{:deps {com.fulcrologic/statecharts                   {:mvn/version "1.2.25"}
        com.wsscode/pathom3                           {:mvn/version "2025.01.16-alpha"}
        com.github.oliyh/martian-babashka-http-client {:mvn/version "0.2.1"}
        org.babashka/http-client                      {:mvn/version "0.4.23"}
        cheshire/cheshire                             {:mvn/version "5.13.0"}
        http-kit/http-kit                             {:mvn/version "2.8.0"}}

 :paths ["src" "test" "src/frontend"]

 :tasks
 {:requires ([clojure.string :as str]
             [babashka.process :refer [shell]])

  ;; Core
  boot
  {:doc "Boot the Ouroboros system"
   :requires ([ouroboros.interface :as iface])
   :task (do (iface/boot!)
             (println "System ready: (iface/q [:system/status])"))}

  nrepl
  {:doc "Start nREPL on port 8888 (tmux: proc-nrepl)"
   :requires ([ouroboros.process-runner :as pr])
   :task (let [port 8888]
           (try (pr/start! "nrepl" "bb nrepl:server")
                (println "[OK] nREPL started on port" port)
                (catch Exception e
                  (when-not (str/includes? (.getMessage e) "already exists")
                    (throw e))
                  (println "[INFO] nREPL already running")))
           (pr/logs "nrepl" :follow? true))}

  nrepl:server
  {:doc "Internal: nREPL server"
   :requires ([babashka.nrepl.server :as nrepl]
              [ouroboros.interface :as iface])
   :task (do (iface/boot!)
             (nrepl/start-server! {:host "localhost" :port 8888})
             (deref (promise)))}

  chat
  {:doc "Start chat bots from environment"
   :requires ([ouroboros.config :as config])
   :task (config/start-from-env!)}

  ;; Dashboard & Frontend
  dashboard
  {:doc "Start dashboard server (tmux: proc-dashboard)"
   :requires ([ouroboros.process-runner :as pr])
   :task (do (try (pr/start! "dashboard" "clojure -M -m ouroboros.dashboard")
                  (println "[OK] Dashboard started")
                  (catch Exception e
                    (when-not (str/includes? (.getMessage e) "already exists")
                      (throw e))))
             (pr/logs "dashboard" :follow? true))}

  frontend:dev
  {:doc "Start shadow-cljs dev server (tmux: proc-frontend-dev)"
   :requires ([ouroboros.process-runner :as pr])
   :task (do (try (pr/start! "frontend-dev" "npx shadow-cljs watch dashboard")
                  (println "[OK] Frontend dev started")
                  (catch Exception e
                    (when-not (str/includes? (.getMessage e) "already exists")
                      (throw e))))
             (pr/logs "frontend-dev" :follow? true))}

  frontend:build
  {:doc "Build frontend for production"
   :task (shell "npx shadow-cljs release dashboard")}

  frontend:install
  {:doc "Install npm dependencies"
   :task (shell "npm install")}

  ;; Dev Stack
  dev
  {:doc "Start full dev stack (blocking)"
   :requires ([ouroboros.process-runner :as pr])
   :task (let [health-url "http://localhost:8080/api/status"
               wait-for (fn [retries]
                          (Thread/sleep 500)
                          (if (try (-> (slurp health-url) (str/includes? "healthy"))
                                   (catch Exception _ false))
                            (println "[OK] Backend ready")
                            (when (pos? retries)
                              (print ".") (flush)
                              (recur (dec retries)))))
               cleanup (fn []
                         (println "\n[STOP] Stopping...")
                         (try (pr/stop! "ouroboros-backend") (catch Exception _))
                         (try (pr/stop! "ouroboros-frontend") (catch Exception _)))]

           (try (pr/start! "ouroboros-backend" "clojure -M -m ouroboros.dashboard")
                (println "[OK] Backend started")
                (catch Exception e
                  (println "[ERROR] Backend:" (.getMessage e))
                  (System/exit 1)))

           (println "[WAIT] Waiting for backend...")
           (wait-for 30)

           (try (pr/start! "ouroboros-frontend" "npx shadow-cljs watch dashboard")
                (println "[OK] Frontend started")
                (catch Exception e
                  (println "[ERROR] Frontend:" (.getMessage e))
                  (cleanup)
                  (System/exit 1)))

           (println "\n=== DEV STACK ===")
           (println "Backend:  http://localhost:8080")
           (println "Frontend: http://localhost:8081")
           (println "Shadow:   http://localhost:9630")
           (println "\nCtrl+C to stop")

           (.addShutdownHook (Runtime/getRuntime) (Thread. cleanup))
           (try (deref (promise))
                (catch InterruptedException _ (cleanup))))}

  dev:start
  {:doc "Start dev stack (non-blocking)"
   :requires ([ouroboros.process-runner :as pr])
   :task (do (try (pr/start! "ouroboros-backend" "clojure -M -m ouroboros.dashboard")
                  (println "[OK] Backend started")
                  (catch Exception e
                    (when-not (str/includes? (.getMessage e) "already exists")
                      (throw e))
                    (println "[INFO] Backend already running")))

             (Thread/sleep 1000)

             (try (pr/start! "ouroboros-frontend" "npx shadow-cljs watch dashboard")
                  (println "[OK] Frontend started")
                  (catch Exception e
                    (when-not (str/includes? (.getMessage e) "already exists")
                      (throw e))
                    (println "[INFO] Frontend already running")))

             (println "\n=== DEV STACK ===")
             (println "Backend:  http://localhost:8080")
             (println "Frontend: http://localhost:8081")
             (println "\nStop: bb dev:stop"))}

  dev:stop
  {:doc "Stop dev stack"
   :requires ([ouroboros.process-runner :as pr])
   :task (do (try (pr/stop! "ouroboros-backend") (println "Backend stopped") (catch Exception _))
             (try (pr/stop! "ouroboros-frontend") (println "Frontend stopped") (catch Exception _)))}

  ;; Process Management
  process
  {:doc "Manage processes (start, stop, logs, attach)"
   :requires ([ouroboros.process-runner])
   :task (apply ouroboros.process-runner/-main *command-line-args*)}

  ;; Utilities
  config
  {:doc "Show configuration"
   :requires ([ouroboros.config :as config])
   :task (do (config/load-config!)
             (clojure.pprint/pprint (config/config-summary)))}

  git:install-hooks
  {:doc "Install git hooks"
   :task (let [source "scripts/git-hooks/pre-commit"
               target ".git/hooks/pre-commit"]
           (if (babashka.fs/exists? source)
             (do (babashka.fs/copy source target {:replace-existing true})
                 (babashka.fs/set-posix-file-permissions target "rwxr-xr-x")
                 (println "Pre-commit hook installed"))
             (println "Hook source not found:" source)))}

  audit:ns
  {:doc "Audit namespace dependencies"
   :task (shell "bb scripts/ns-audit.clj")}

  download
  {:doc "Fast download with auto-resume"
   :task (let [args *command-line-args*]
           (if (seq args)
             (apply shell "bb" "scripts/fast-download.clj" args)
             (do (println "Usage: bb download <url> [file] [-c 16]")
                 (println "  -c N  Connections (default: 16)"))))}

  ;; Testing
  test
  {:doc "Run all tests"
   :requires ([clojure.test :as t])
   :task (do (println "\n=== Running Tests ===")
             (require 'ouroboros.core-test)
             (require 'ouroboros.chat-adapter-test)
             (require 'ouroboros.streaming-test)
             (require 'ouroboros.tool-execution-test)
             (require 'ouroboros.integration-test)
             (let [results [(t/run-tests 'ouroboros.core-test)
                           (t/run-tests 'ouroboros.chat-adapter-test)
                           (t/run-tests 'ouroboros.streaming-test)
                           (t/run-tests 'ouroboros.tool-execution-test)
                           (t/run-tests 'ouroboros.integration-test)]
                   sum (fn [k] (apply + (map k results)))]
               (println "\n=== Results ===")
               (println "Tests:" (sum :test) "Pass:" (sum :pass)
                        "Fail:" (sum :fail) "Error:" (sum :error))
               (when (and (zero? (sum :fail)) (zero? (sum :error)))
                 (println "ALL TESTS PASSED!"))
               (System/exit (if (and (zero? (sum :fail)) (zero? (sum :error))) 0 1))))}

  test:webux
  {:doc "Run WebUX tests (requires Clojure)"
   :task (shell "clojure -M -e \"(load-file \\\"scripts/test_webux_jvm.clj\\\") ((resolve 'scripts.test-webux-jvm/-main))\"")}

  test:eca
  {:doc "Run ECA integration tests"
   :requires ([clojure.test :as t])
   :task (do (println "\n=== ECA Tests ===")
             (require 'ouroboros.eca-client-test)
             (require 'ouroboros.eca-approval-bridge-test)
             (require 'ouroboros.eca-integration-test)
             (require 'ouroboros.eca-protocol-test)
             (require 'ouroboros.eca-websocket-integration-test)
             (let [results [(t/run-tests 'ouroboros.eca-client-test)
                           (t/run-tests 'ouroboros.eca-approval-bridge-test)
                           (t/run-tests 'ouroboros.eca-integration-test)
                           (t/run-tests 'ouroboros.eca-protocol-test)
                           (t/run-tests 'ouroboros.eca-websocket-integration-test)]
                   sum (fn [k] (apply + (map k results)))]
               (println "\n=== Results ===")
               (println "Tests:" (sum :test) "Pass:" (sum :pass)
                        "Fail:" (sum :fail) "Error:" (sum :error))
               (System/exit (if (and (zero? (sum :fail)) (zero? (sum :error))) 0 1))))}

  debug
  {:doc "Debug utilities: bb debug [eca|system|tools|menu]"
   :requires ([ouroboros.debug :as dbg])
   :task (case (first *command-line-args*)
           ("eca" nil) (let [s (dbg/eca-status)]
                         (println "\n=== ECA ===")
                         (if (:exists? s)
                           (println "✓" (:path s) "(" (:version s) ")")
                           (println "✗ Not found at" (:path s))))
           ("system" "status") (dbg/system-status)
           ("tools") (dbg/tool-registry)
           ("menu" "help") (dbg/debug-menu)
           (println "Usage: bb debug [eca|system|tools|menu]"))}}}
